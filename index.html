<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="加油！">
<meta property="og:type" content="website">
<meta property="og:title" content="Zard博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Zard博客">
<meta property="og:description" content="加油！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SoulSend">
<meta property="article:tag" content="hexo">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zard博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zard博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SoulSend"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">SoulSend</p>
  <div class="site-description" itemprop="description">加油！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/GIt%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/GIt%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">Git指令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-08 09:48:33" itemprop="dateModified" datetime="2024-10-08T09:48:33+08:00">2024-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="GIt"><a href="#GIt" class="headerlink" title="GIt"></a>GIt</h1><h4 id="一、安装git"><a href="#一、安装git" class="headerlink" title="一、安装git"></a>一、安装git</h4><p>windows直接上官网下载安装包，然后无脑安装就行了。</p>
<h5 id="1、右键桌面，更多选项，如果有git-bash这个选项就是安装成功了"><a href="#1、右键桌面，更多选项，如果有git-bash这个选项就是安装成功了" class="headerlink" title="1、右键桌面，更多选项，如果有git bash这个选项就是安装成功了"></a>1、右键桌面，更多选项，如果有git bash这个选项就是安装成功了</h5><h5 id="2、：打开git-bash，然后输入指令进行配置："><a href="#2、：打开git-bash，然后输入指令进行配置：" class="headerlink" title="2、：打开git bash，然后输入指令进行配置："></a>2、：打开git bash，然后输入指令进行配置：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h4 id="二、创建版本库"><a href="#二、创建版本库" class="headerlink" title="二、创建版本库"></a>二、创建版本库</h4><h5 id="1、先创建一个空目录啥也没有"><a href="#1、先创建一个空目录啥也没有" class="headerlink" title="1、先创建一个空目录啥也没有"></a>1、先创建一个空目录啥也没有</h5><h5 id="2、在这个目录中使用git-bash打开，然后输入指令："><a href="#2、在这个目录中使用git-bash打开，然后输入指令：" class="headerlink" title="2、在这个目录中使用git bash打开，然后输入指令："></a>2、在这个目录中使用git bash打开，然后输入指令：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>这就是初始化一个版本库的指令，然后你就会看到你的目录中多了一个.git文件，没看到就是文件被隐藏了，在上面的查看里选择显示，然后勾选隐藏的项目。</p>
<p>说明：所有的版本控制系统，其实只能跟踪文本文件的改动。Windows用户不建议使用自带的记事本，可以使用vscode来充当记事本，vc颜值高，启动快，啥都能干！还免费！</p>
<h4 id="三、提交改动"><a href="#三、提交改动" class="headerlink" title="三、提交改动"></a>三、提交改动</h4><h5 id="1、先把git版本库里的文件改动一点或者添加一个文件"><a href="#1、先把git版本库里的文件改动一点或者添加一个文件" class="headerlink" title="1、先把git版本库里的文件改动一点或者添加一个文件"></a>1、先把git版本库里的文件改动一点或者添加一个文件</h5><h5 id="2、然后输入指令，查看当前仓库的变动"><a href="#2、然后输入指令，查看当前仓库的变动" class="headerlink" title="2、然后输入指令，查看当前仓库的变动"></a>2、然后输入指令，查看当前仓库的变动</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h5 id="3、输入指令查看具体的改动的内容："><a href="#3、输入指令查看具体的改动的内容：" class="headerlink" title="3、输入指令查看具体的改动的内容："></a>3、输入指令查看具体的改动的内容：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 文件名</span><br></pre></td></tr></table></figure>

<h5 id="4、再输入指令，提交改动到暂缓区："><a href="#4、再输入指令，提交改动到暂缓区：" class="headerlink" title="4、再输入指令，提交改动到暂缓区："></a>4、再输入指令，提交改动到暂缓区：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .    //这个指令后面带的点是一个通配符的感觉，指的是所有改动的文件</span><br><span class="line">git add 文件名 //你也可以使用这个指令来指定提交某个文件</span><br></pre></td></tr></table></figure>

<h5 id="5、再输入指令，提交改动到本地版本库："><a href="#5、再输入指令，提交改动到本地版本库：" class="headerlink" title="5、再输入指令，提交改动到本地版本库："></a>5、再输入指令，提交改动到本地版本库：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m “本次提交的信息” //注意后面的 -m 参数是必要的，可以不指定提交的信息，但这要使用一个参数，我的说法是加上这个-m参数是很有必要的，方便追踪</span><br></pre></td></tr></table></figure>

<h5 id="6、查看文件内容："><a href="#6、查看文件内容：" class="headerlink" title="6、查看文件内容："></a>6、查看文件内容：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat readme.txt//可以看到当前文件的内容</span><br></pre></td></tr></table></figure>



<h4 id="四、版本回溯"><a href="#四、版本回溯" class="headerlink" title="四、版本回溯"></a>四、版本回溯</h4><h5 id="注意：这是版本控制系统很重要的部分。"><a href="#注意：这是版本控制系统很重要的部分。" class="headerlink" title="注意：这是版本控制系统很重要的部分。"></a>注意：这是版本控制系统很重要的部分。</h5><p><strong>前言：</strong>head是一个指针，这个指针指向当前的版本，所以回溯版本就是修改head指针的指向，然后修改暂存区的内容</p>
<h5 id="1、查看提交的版本："><a href="#1、查看提交的版本：" class="headerlink" title="1、查看提交的版本："></a>1、查看提交的版本：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log //从上到下 由新到旧</span><br><span class="line">git log --pretty=oneline //参数是限制显示的行数，将不必要的信息过滤</span><br><span class="line"></span><br><span class="line">注意：使用git log以后想要退出查看日志的切面，按q键</span><br></pre></td></tr></table></figure>

<h5 id="2、回溯到以前的某一个版本"><a href="#2、回溯到以前的某一个版本" class="headerlink" title="2、回溯到以前的某一个版本"></a>2、回溯到以前的某一个版本</h5><h5 id="注意：在使用回溯前，请先使用一下-git-log-–pretty-oneline-来查看一下当前版本的版本号，这样即使回溯后后悔了也可以恢复到原来"><a href="#注意：在使用回溯前，请先使用一下-git-log-–pretty-oneline-来查看一下当前版本的版本号，这样即使回溯后后悔了也可以恢复到原来" class="headerlink" title="注意：在使用回溯前，请先使用一下 git log –pretty&#x3D;oneline 来查看一下当前版本的版本号，这样即使回溯后后悔了也可以恢复到原来"></a>注意：在使用回溯前，请先使用一下 git log –pretty&#x3D;oneline 来查看一下当前版本的版本号，这样即使回溯后后悔了也可以恢复到原来</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^ //head^表示上一个版本 ^^表示上两个版本 </span><br></pre></td></tr></table></figure>

<h5 id="3、回溯后后悔了，想回到以前，这时需要用到版本号了（注意这时你的git-bash窗口还没有关闭，可以查看前面的版本号）"><a href="#3、回溯后后悔了，想回到以前，这时需要用到版本号了（注意这时你的git-bash窗口还没有关闭，可以查看前面的版本号）" class="headerlink" title="3、回溯后后悔了，想回到以前，这时需要用到版本号了（注意这时你的git bash窗口还没有关闭，可以查看前面的版本号）"></a>3、回溯后后悔了，想回到以前，这时需要用到版本号了（注意这时你的git bash窗口还没有关闭，可以查看前面的版本号）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号 //版本号有长 16位 使用前七位就够了，git会自动根据前七位来找</span><br></pre></td></tr></table></figure>

<h5 id="4、回溯后后悔了，然后git-bash窗口也关闭了，查看不了版本号咋整？使用指令："><a href="#4、回溯后后悔了，然后git-bash窗口也关闭了，查看不了版本号咋整？使用指令：" class="headerlink" title="4、回溯后后悔了，然后git bash窗口也关闭了，查看不了版本号咋整？使用指令："></a>4、回溯后后悔了，然后git bash窗口也关闭了，查看不了版本号咋整？使用指令：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog //这个指令可以查看你的每一次命令，然后你就可以看到指令前的回溯前的版本号了</span><br></pre></td></tr></table></figure>



<h4 id="五、撤销修改"><a href="#五、撤销修改" class="headerlink" title="五、撤销修改"></a>五、撤销修改</h4><h5 id="1、当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令："><a href="#1、当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令：" class="headerlink" title="1、当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令："></a>1、当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- 文件名 //让这个文件回到最近一次git commit或git add时的状态。其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</span><br></pre></td></tr></table></figure>

<h5 id="注意：git-checkout-file命令中的-很重要，没有-，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git-checkout命令。"><a href="#注意：git-checkout-file命令中的-很重要，没有-，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git-checkout命令。" class="headerlink" title="注意：git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。"></a>注意：<code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</h5><h5 id="2、当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令就回到了-1，第二步按1操作。"><a href="#2、当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令就回到了-1，第二步按1操作。" class="headerlink" title="2、当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令就回到了 1，第二步按1操作。"></a>2、当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令就回到了 1，第二步按1操作。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD 文件名 //可以把暂存区的修改撤销掉（unstage），重新放回工作区</span><br></pre></td></tr></table></figure>

<h5 id="3、已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回溯，不过前提是没有推送到远程库。"><a href="#3、已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回溯，不过前提是没有推送到远程库。" class="headerlink" title="3、已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回溯，不过前提是没有推送到远程库。"></a>3、已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回溯，不过前提是没有推送到远程库。</h5><h4 id="六、远程仓库"><a href="#六、远程仓库" class="headerlink" title="六、远程仓库"></a>六、远程仓库</h4><p>​	这是git的杀手锏之一，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。使用GitHub来充当这个服务器角色！这个服务器就是远程仓库。</p>
<h5 id="1、创建SSH密钥"><a href="#1、创建SSH密钥" class="headerlink" title="1、创建SSH密钥"></a>1、创建SSH密钥</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot; //你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</span><br></pre></td></tr></table></figure>

<p>​	如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<h5 id="2、登陆GitHub，打开“Account-settings”，“SSH-Keys”页面，然后，点“Add-SSH-Key”，填上任意Title，在Key文本框里粘贴id-rsa-pub文件的内容，然后就可以了。"><a href="#2、登陆GitHub，打开“Account-settings”，“SSH-Keys”页面，然后，点“Add-SSH-Key”，填上任意Title，在Key文本框里粘贴id-rsa-pub文件的内容，然后就可以了。" class="headerlink" title="2、登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，然后就可以了。"></a>2、登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容，然后就可以了。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</span><br></pre></td></tr></table></figure>

<h5 id="3、本地关联远程仓库"><a href="#3、本地关联远程仓库" class="headerlink" title="3、本地关联远程仓库"></a>3、本地关联远程仓库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin ssh路径  //ssh路径像这样：git@github.com:SoulSend/MyTomcat.git。同时origin也是这个连接的别名，可以使用origin代替这个路径</span><br></pre></td></tr></table></figure>

<p>​	添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<h5 id="4、推送本地到远程仓库："><a href="#4、推送本地到远程仓库：" class="headerlink" title="4、推送本地到远程仓库："></a>4、推送本地到远程仓库：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push [-u] origin master //第一次使用的时候添加一个-u 参数，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来</span><br><span class="line"></span><br><span class="line">git push origin master  //第二次提交：就可以使用这个了</span><br></pre></td></tr></table></figure>

<h5 id="5、SSH警告"><a href="#5、SSH警告" class="headerlink" title="5、SSH警告"></a>5、SSH警告</h5><p>​	当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<p>​	这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>
<p>​	Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>

<p>​	这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<h5 id="6、删除远程仓库"><a href="#6、删除远程仓库" class="headerlink" title="6、删除远程仓库"></a>6、删除远程仓库</h5><p>​	如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure>

<p>​	然后，根据名字删除，比如删除<code>origin</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>

<p>​	此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>
<h5 id="7、克隆远程仓库"><a href="#7、克隆远程仓库" class="headerlink" title="7、克隆远程仓库"></a>7、克隆远程仓库</h5><p>​	前面是先有本地库，后有远程库的时候，如何关联远程库。假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。创建好一个远程仓库，然后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:SoulSend/MyTomcat.git //ssh连接 也可以使用https路径，但是慢且幺蛾子多</span><br></pre></td></tr></table></figure>



<h4 id="七、分支管理"><a href="#七、分支管理" class="headerlink" title="七、分支管理"></a>七、分支管理</h4><p>​	<strong>使用场景：</strong>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>​	<strong>分支的原理：</strong>前面提到的head指针，它指向的分支就是当前分支。一个分支就像是一个链表。git用master指向链表的头部，使用head指向master，每次提交，master向前走一步。当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上。Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变。假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并</p>
<h5 id="1、创建分支、合并分支、删除分支"><a href="#1、创建分支、合并分支、删除分支" class="headerlink" title="1、创建分支、合并分支、删除分支"></a>1、创建分支、合并分支、删除分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名   //创建分支</span><br><span class="line">git checkout 分支名   //切换分支</span><br><span class="line">git checkout -b 分支名  //创建然后切换分支</span><br><span class="line"></span><br><span class="line">由于前面提到 checkout指令还可以用来撤销修改，新版git为了避免混淆，切换分支还可以使用git switch：</span><br><span class="line">git switch -c 分支名 //创建然后切换分支</span><br><span class="line">git switch 分支名 //切换到已有的分支</span><br><span class="line"></span><br><span class="line">git merge 分支名  //合并分支</span><br><span class="line"></span><br><span class="line">git branch -d 分支名 //删除分支</span><br><span class="line">git branch -D 分支名 //强制删除分支</span><br><span class="line">git push origin --delete 分支名  //删除远程分支</span><br></pre></td></tr></table></figure>

<h6 id="注意：要在当前分支下创建分支，他们俩才有关系，才能合并，不然在使用合并代码后是会报错的，提示两个分支没有相同的历史，这时可以使用强制合并"><a href="#注意：要在当前分支下创建分支，他们俩才有关系，才能合并，不然在使用合并代码后是会报错的，提示两个分支没有相同的历史，这时可以使用强制合并" class="headerlink" title="注意：要在当前分支下创建分支，他们俩才有关系，才能合并，不然在使用合并代码后是会报错的，提示两个分支没有相同的历史，这时可以使用强制合并"></a>注意：要在当前分支下创建分支，他们俩才有关系，才能合并，不然在使用合并代码后是会报错的，提示两个分支没有相同的历史，这时可以使用强制合并</h6><h5 id="2、分支合并冲突，当两个分支修改同一份文件后合并时就会出现分支合并冲突，此时git会提醒你产生冲突了，要解决冲突。然后你就将两个文件相同的地方改为一个，然后再提交。"><a href="#2、分支合并冲突，当两个分支修改同一份文件后合并时就会出现分支合并冲突，此时git会提醒你产生冲突了，要解决冲突。然后你就将两个文件相同的地方改为一个，然后再提交。" class="headerlink" title="2、分支合并冲突，当两个分支修改同一份文件后合并时就会出现分支合并冲突，此时git会提醒你产生冲突了，要解决冲突。然后你就将两个文件相同的地方改为一个，然后再提交。"></a>2、分支合并冲突，当两个分支修改同一份文件后合并时就会出现分支合并冲突，此时git会提醒你产生冲突了，要解决冲突。然后你就将两个文件相同的地方改为一个，然后再提交。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit //这个指令可以查看分支的合并情况</span><br></pre></td></tr></table></figure>

<h5 id="3、分支管理策略"><a href="#3、分支管理策略" class="headerlink" title="3、分支管理策略"></a>3、分支管理策略</h5><p>​	在实际开发中，我们应该按照几个基本原则进行分支管理：首先，**<code>master</code>分支应该是非常稳定的<strong>，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？</strong>干活都在<code>dev</code>分支上**，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<h5 id="4、bug分支"><a href="#4、bug分支" class="headerlink" title="4、bug分支"></a>4、bug分支</h5><p>​	软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p><strong>场景：</strong>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash  </span><br></pre></td></tr></table></figure>

<p>使用完这个指令以后，当前的工作区就是干净的，你先前的工作现场被保存了。然后你就可以切换分支去改bug去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master //切换到有bug的分支</span><br><span class="line">git checkout -b issue-101 //创建一个修改bug的临时分支 假设这个bug的代号是101</span><br><span class="line">.....修改bug</span><br><span class="line">git switch master //修复完成后，切换到master分支，并完成合并，最后删除issue-101分支</span><br><span class="line">git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 // --no-ff 参数在合并分支后，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。所以在合并分支的同时会有commit 所以携带参数-m &quot;merged bug fix 101&quot;</span><br></pre></td></tr></table></figure>

<p>改完bug了怎么恢复刚才的现场呢？切换会先前的工作分支，然后查看保存的现场信息，然后恢复现场继续工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash list </span><br><span class="line">恢复现场有两种方法：</span><br><span class="line"></span><br><span class="line">一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 </span><br><span class="line">apply后面可以跟：stash@&#123;0&#125;你想恢复的现场的编号来指定恢复哪个现场</span><br><span class="line"></span><br><span class="line">另一种方式是用git stash pop，恢复的同时把stash内容也删了</span><br></pre></td></tr></table></figure>

<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick 4c805e2 //后面的数字就是对应提交的版本号</span><br></pre></td></tr></table></figure>

<h5 id="5、多人协作"><a href="#5、多人协作" class="headerlink" title="5、多人协作"></a>5、多人协作</h5><p>多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p>但是这样操作后，分支看上去会很混乱，可以使用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase //把分支整理成一条直线</span><br></pre></td></tr></table></figure>

<h4 id="八、标签管理"><a href="#八、标签管理" class="headerlink" title="八、标签管理"></a>八、标签管理</h4><h5 id="1、创建标签"><a href="#1、创建标签" class="headerlink" title="1、创建标签"></a>1、创建标签</h5><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上，然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure>

<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>

<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline --abbrev-commit //找到历史提交的commit id</span><br></pre></td></tr></table></figure>

<p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.9 f52c633</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息</p>
<p>还可以创建带有说明的标签，<strong>用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure>

<h5 id="2、操作标签"><a href="#2、操作标签" class="headerlink" title="2、操作标签"></a>2、操作标签</h5><p>删除标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签到远程仓库；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<h5 id="九、使用GitHub参与开源项目"><a href="#九、使用GitHub参与开源项目" class="headerlink" title="九、使用GitHub参与开源项目"></a>九、使用GitHub参与开源项目</h5><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a target="_blank" rel="noopener" href="https://github.com/twbs/bootstrap%EF%BC%8C%E7%82%B9%E2%80%9CFork%E2%80%9D%E5%B0%B1%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%A6%E5%8F%B7%E4%B8%8B%E5%85%8B%E9%9A%86%E4%BA%86%E4%B8%80%E4%B8%AAbootstrap%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%EF%BC%8C%E4%BB%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%A6%E5%8F%B7%E4%B8%8Bclone%EF%BC%9A">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:Soulsend/bootstrap.git</span><br></pre></td></tr></table></figure>

<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p>
<p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/Java%20Se/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/Java%20Se/" class="post-title-link" itemprop="url">JavaSe</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:17:39" itemprop="dateModified" datetime="2024-11-20T21:17:39+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-Se"><a href="#Java-Se" class="headerlink" title="Java Se"></a>Java Se</h1><h4 id="内容：Maven工具，JDBC接口，反射和注解，23种设计模式"><a href="#内容：Maven工具，JDBC接口，反射和注解，23种设计模式" class="headerlink" title="内容：Maven工具，JDBC接口，反射和注解，23种设计模式"></a>内容：Maven工具，JDBC接口，反射和注解，23种设计模式</h4><h3 id="一、Maven工具"><a href="#一、Maven工具" class="headerlink" title="一、Maven工具"></a>一、Maven工具</h3><h4 id="1、maven的介绍："><a href="#1、maven的介绍：" class="headerlink" title="1、maven的介绍："></a>1、maven的介绍：</h4><p>​	<strong>maven</strong>就是一个构建web项目的工具，可以帮助开发人员管理web项目中的各种依赖。</p>
<p>​	在日常开发过程我们要用到第三方的框架或者是jar包就需要在网上找到这个框架或者jar包然后下载下来复制到我们项目的目录中，如果有多个框架还要注意框架的版本之间是否冲突，这些工作简单但是非常繁琐，所以我们将这些重复且繁琐的工作抽象出来，专门搞一个工具来完成这些操作，我们只需要使用这个工具就可以简单地完成，类似于脚本，不过maven是一个软件&#x2F;工具。</p>
<h4 id="2、maven的作用："><a href="#2、maven的作用：" class="headerlink" title="2、maven的作用："></a>2、maven的作用：</h4><h5 id="一键构建项目（如图）："><a href="#一键构建项目（如图）：" class="headerlink" title="一键构建项目（如图）："></a>一键构建项目（如图）：</h5><p><img src="/images%5Cmvn2.png" alt="mvn2"></p>
<p>​	使用maven生成的项目的结构都是一样的，src&#x2F;main&#x2F;java存放项目源码，src&#x2F;main&#x2F;resources存放项目的资源文件，test&#x2F;java存放测试源码。这样所有使用maven生成的项目结构都是一样的，非常容易上手管理陌生项目。</p>
<p>​	使用maven的指令可以快捷实现清理 编译、测试、运行、打包、安装、部署，只需要在maven项目的目录里打开控制台输入对应的mvn指令就可以实现打包、运行这些操作，如果你是idea可以直接使用idea集成的maven工具里的生命周期</p>
<h5 id="依赖管理，也就是管理jar包："><a href="#依赖管理，也就是管理jar包：" class="headerlink" title="依赖管理，也就是管理jar包："></a>依赖管理，也就是管理jar包：</h5><p>​	传统web项目中我们需要复制依赖到项目的目录里面。前面说了，这个过程很繁琐而且jar包过多还会导致项目文件过大。所以使用maven来帮我们导入依赖管理依赖，缩小工程的大小。</p>
<p>​	maven是怎么实现这样的功能的呢？maven不会将jar包直接导入到工程中，而需要你在pom.xml中写上依赖的坐标，然后maven就会自动根据坐标在本地的仓库（安装maven后配置maven的时候指定的本地仓库目录就是存放依赖的）寻找，没找到回去镜像找，还没有就去中央仓库找。找到这个jar包后直接拿来运行，不会复制到项目里，这样就避免jar包过多使得项目太大。至于担心这样会影响程序运行速度（跑去找jar包），不必担心，maven就像数据库一样建立了索引，检索依赖非常快，和本地文件中的依赖速度区别不大。</p>
<h4 id="思考：我在学习的时候有个疑问，maven是怎么把本地仓库的依赖和工程项目文件连接在一起的，简单来说就是：我的依赖在本地仓库，并没有在工程文件里面，工程源码是怎么调用这些jar包的？然后我就跑去搜，搜了半天搜不出来，干脆跑去问AI，然后绕了一大圈可算是弄懂了。"><a href="#思考：我在学习的时候有个疑问，maven是怎么把本地仓库的依赖和工程项目文件连接在一起的，简单来说就是：我的依赖在本地仓库，并没有在工程文件里面，工程源码是怎么调用这些jar包的？然后我就跑去搜，搜了半天搜不出来，干脆跑去问AI，然后绕了一大圈可算是弄懂了。" class="headerlink" title="思考：我在学习的时候有个疑问，maven是怎么把本地仓库的依赖和工程项目文件连接在一起的，简单来说就是：我的依赖在本地仓库，并没有在工程文件里面，工程源码是怎么调用这些jar包的？然后我就跑去搜，搜了半天搜不出来，干脆跑去问AI，然后绕了一大圈可算是弄懂了。"></a>思考：我在学习的时候有个疑问，maven是怎么把本地仓库的依赖和工程项目文件连接在一起的，简单来说就是：我的依赖在本地仓库，并没有在工程文件里面，工程源码是怎么调用这些jar包的？然后我就跑去搜，搜了半天搜不出来，干脆跑去问AI，然后绕了一大圈可算是弄懂了。</h4><p>​	简单来说就是，<strong>maven会自动在编译项目的时候动态添加依赖到类路径中</strong>，从而使得项目文件可以调用这些jar包里面的类。如果从网络上下载了一个maven项目，而我本地从来没有使用过maven。没有本地仓库，在运行前是要先让maven自动下载完依赖到本地仓库然后在编译的时候才能动态加载这些依赖到类路径里。<strong>而不使用maven工具的项目</strong>，所有的jar包都放在工程文件里，就不需要再下载jar包，可以直接运行工程。</p>
<p>​	<strong>maven项目和非maven项目的大小是不一样的</strong>，maven项目是在编译项目的时候将本地仓库的类链接到项目的类路径里面，而非maven项目是一直都包含这些jar包的时候。举个例子：当你要运行多个非maven项目，不管他们是否有相同的jar包，都是以项目为单位单独编译的，相同的依赖在不同的项目中有多份。而多个maven项目要运行，所有的第三方依赖都在仓库里，在使用时动态加载，每个相同的依赖只有一份，我的项目里只有我自己编写的源码和依赖坐标，这样项目的大小就比普通项目大小要小，减少磁盘浪费。</p>
<h3 id="二、JDBC接口"><a href="#二、JDBC接口" class="headerlink" title="二、JDBC接口"></a>二、JDBC接口</h3><h4 id="1、jdbc介绍："><a href="#1、jdbc介绍：" class="headerlink" title="1、jdbc介绍："></a>1、jdbc介绍：</h4><p>​	jdbc是java官方提供的一套接口，为什么要提供这套接口呢？为了方便java使用代码操作不同的数据库，所以给出了一个统一的接口，所有数据库厂家，根据这套接口实现接口的所有类，然后封装打成jar包（依赖）。我们在使用java操作数据库的时候直接调用jdbc接口来编程，然后引入数据库驱动，就可以直接使用java代码操作数据库了。当我们更换数据库的时候，java源码一个不用改，直接换一个数据库驱动就行了。这就是接口的好处，我们不用关心接口是怎么运行的直接调用接口就行了，数据库厂家帮我们实现好了。</p>
<h4 id="2、jdbc的使用："><a href="#2、jdbc的使用：" class="headerlink" title="2、jdbc的使用："></a>2、jdbc的使用：</h4><p>​	在idea中使用集成的可视化数据库工具先创建一个数据库同时插入数据，然后创建一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MyfirstJdbc &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //1、加载驱动</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        </span><br><span class="line">        //2、连接数据库。用户信息和url 安装mysql的时候选择的用户名和密码</span><br><span class="line">        String url=&quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&quot;;//?号后面是参数，设置数据库使用的编码格式和解码格式</span><br><span class="line">        String username=&quot;root&quot;;</span><br><span class="line">        String password=&quot;123456&quot;;</span><br><span class="line">        //连接数据库,返回数据库对象connection</span><br><span class="line">        Connection connection= DriverManager.getConnection(url,username,password);</span><br><span class="line">        </span><br><span class="line">        //3、建立查询，执行sql语句。创建执行sql语句的对象statement 相当于数据库操作中的新建一个查询</span><br><span class="line">        Statement statement= connection.createStatement();</span><br><span class="line">        String sql =  &quot;select * from users&quot;;</span><br><span class="line">        //在查询里面编写sql语句</span><br><span class="line">        ResultSet resultSet=statement.executeQuery(sql);</span><br><span class="line">        //输出结果</span><br><span class="line">        while(resultSet.next())&#123;</span><br><span class="line">            System.out.println(&quot;id&quot;+resultSet.getObject(&quot;id&quot;));</span><br><span class="line">            System.out.println(&quot;name&quot;+resultSet.getObject(&quot;name&quot;));</span><br><span class="line">            System.out.println(&quot;password&quot;+resultSet.getObject(&quot;password&quot;));</span><br><span class="line">            System.out.println(&quot;email&quot;+resultSet.getObject(&quot;email&quot;));</span><br><span class="line">            System.out.println(&quot;birthday&quot;+resultSet.getObject(&quot;birthday&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭连接，释放资源，一个连接是非常“贵”的，占用宝贵的系统资源</span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上面的代码就是使用jdbc操作数据库的一个demo，总结就是三个流程：</p>
<ul>
<li><p>加载驱动</p>
</li>
<li><p>连接数据库</p>
</li>
<li><p>通过连接获取查询，通过查询注入sql语句实现数据库操作</p>
<p>当然，上面的操作不好记忆，所以我建议使用可视化界面来辅助记忆，多看两遍就会写了：</p>
<p><img src="/images%5C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5.png" alt="数据库连接"></p>
</li>
</ul>
<p>​	上图中的用户密码url就是代码中建立连接需要的配置数据，加载驱动要点击测试链接，会自动加载驱动。然后在连接号数据库以后，可以通过兴建查询来编写sql语句，流程一样，只不过一个是可视化界面实现，一个是java接口实现。</p>
<p>​	额外要说的是使用Statement会出现sql注入的问题，建议使用他的继承类PreparedStatement，预编译sql而不是字符串拼接</p>
<h3 id="三、反射和注解"><a href="#三、反射和注解" class="headerlink" title="三、反射和注解"></a>三、反射和注解</h3><h4 id="1、反射的理解："><a href="#1、反射的理解：" class="headerlink" title="1、反射的理解："></a>1、反射的理解：</h4><p>​	<strong>反射：</strong>我理解为 类 的 类。 通过对类进行抽象，提取出类的公共特征：构造器，属性，方法，为了方便描述现在我暂且称之为反射，然后我们 让某个具体的类 来实例化 这个反射 ，那么反射被具体的类实例化以后，我们就可以通过这个反射获取这个类的成员变量，构造器，方法。以上是我的个人理解，嗯，暂时是这样理解的。</p>
<h4 id="2、反射的使用："><a href="#2、反射的使用：" class="headerlink" title="2、反射的使用："></a>2、反射的使用：</h4><p>​	<strong>字节码文件：</strong>关于反射有一个在JVM虚拟机里面的概念叫做字节码文件，这个文件是java的编译程序在对java源代码进行编译以后产生的“目标文件”，字节码文件在经过JVM虚拟机翻译以后生成对应的操作系统的二进制“可执行文件”。</p>
<p>​	在反射中，我们可以通过获取类的字节码文件，然后<strong>解析字节码文件</strong>来获取这个类的所有“属性”也就是这个类的构造器，方法，成员变量。</p>
<p>​	<strong>获取类的字节码：</strong></p>
<ul>
<li><p>Class c1 &#x3D; 类名.class</p>
</li>
<li><p>调用Class提供的静态方法：forname（类的全类名）</p>
</li>
<li><p>通过类的实例调用Object提供的方法：Class c1&#x3D;类的实例.getClass()</p>
<p>你看，获取这个字节码文件的属性名字是什么？ Class ! Class类，不就是类的类嘛，类名.class这也叫获取这个类的class的对象。或许这样说不太准确，但是这可以帮助我们理解反射这个抽象的概念。</p>
<p><strong>至于对于获取类的构造器，成员变量，方法</strong>等具体Class方法，百度即可，和正常的方法调用没啥区别。</p>
</li>
</ul>
<h4 id="3、反射的应用："><a href="#3、反射的应用：" class="headerlink" title="3、反射的应用："></a>3、反射的应用：</h4><pre><code>    通过Java的反射机制编写底层框架通常涉及到动态地加载类、创建对象、调用方法等操作。以下是一个简单的示例，展示如何使用反射来创建一个简单的依赖注入框架。
</code></pre>
<h5 id="步骤-1-定义组件接口"><a href="#步骤-1-定义组件接口" class="headerlink" title="步骤 1: 定义组件接口"></a>步骤 1: 定义组件接口</h5><p>​	首先，我们定义一个组件接口，所有的组件都需要实现这个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-2-创建具体的组件实现"><a href="#步骤-2-创建具体的组件实现" class="headerlink" title="步骤 2: 创建具体的组件实现"></a>步骤 2: 创建具体的组件实现</h5><p>然后，我们创建具体的组件实现。<strong>这个组件就是一个类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Performing task in ConcreteComponent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-3-编写依赖注入容器"><a href="#步骤-3-编写依赖注入容器" class="headerlink" title="步骤 3: 编写依赖注入容器"></a>步骤 3: 编写依赖注入容器</h5><p>​	接下来，我们编写一个简单的依赖注入容器，它使用反射来查找和实例化组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyInjector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; components = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//一个键值对集合，键为String类型，值为字节码对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerComponent</span><span class="params">(String name, Class&lt;?&gt; componentClass)</span> &#123;</span><br><span class="line">        components.put(name, componentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getComponent</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; componentClass = components.get(name);<span class="comment">//通过键值获取对应的字节码对象</span></span><br><span class="line">        <span class="keyword">if</span> (componentClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            Constructor&lt;?&gt; constructor = componentClass.getConstructor();<span class="comment">//获取这个对象的构造器</span></span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance();<span class="comment">//创建这个类的实例</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Component not found: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-4-使用依赖注入容器"><a href="#步骤-4-使用依赖注入容器" class="headerlink" title="步骤 4: 使用依赖注入容器"></a>步骤 4: 使用依赖注入容器</h5><p>​	最后，我们使用依赖注入容器来获取组件实例，并执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DependencyInjector</span> <span class="variable">injector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyInjector</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册组件</span></span><br><span class="line">        injector.registerComponent(<span class="string">&quot;myComponent&quot;</span>, ConcreteComponent.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取组件实例并执行任务</span></span><br><span class="line">            <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> (Component) injector.getComponent(<span class="string">&quot;myComponent&quot;</span>);</span><br><span class="line">            component.performTask();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这个示例展示了如何使用反射来实现一个简单的依赖注入框架。在这个框架中，我们定义了一个组件接口和一个具体的组件实现。然后，我们创建了一个依赖注入容器，它能够根据提供的名称动态地加载和实例化组件。最后，我们使用这个容器来获取组件实例，并调用其方法。</p>
<p>​	Springboot的依赖注入大抵就是这样的原理实现的，依赖注入就是将一个类的实例（bean）注入到注解@Autowired标识的那个类的实例里，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">public Student s;</span><br></pre></td></tr></table></figure>

<p>​	依赖注入就是将创建好的Student类的实例（bean）赋给 这个 s。</p>
<h5 id="那么又回到反射的应用，就是使用”类的类”这个特点来编写一个工具，这个工具干什么呢？使用上面的例子来说明，我们编写这个依赖注入容器（这就是工具）的时候，不知道会传入些什么类，所以我们使用反射，也就是字节码对象来动态获取未知的类（好像类的变量），获取这个类以后，我们调用这个类的构造器创建一个对象然后返回这个对象。Object类是无法实现这些功能的，他没有那些获取构造器的方法等等。"><a href="#那么又回到反射的应用，就是使用”类的类”这个特点来编写一个工具，这个工具干什么呢？使用上面的例子来说明，我们编写这个依赖注入容器（这就是工具）的时候，不知道会传入些什么类，所以我们使用反射，也就是字节码对象来动态获取未知的类（好像类的变量），获取这个类以后，我们调用这个类的构造器创建一个对象然后返回这个对象。Object类是无法实现这些功能的，他没有那些获取构造器的方法等等。" class="headerlink" title="那么又回到反射的应用，就是使用”类的类”这个特点来编写一个工具，这个工具干什么呢？使用上面的例子来说明，我们编写这个依赖注入容器（这就是工具）的时候，不知道会传入些什么类，所以我们使用反射，也就是字节码对象来动态获取未知的类（好像类的变量），获取这个类以后，我们调用这个类的构造器创建一个对象然后返回这个对象。Object类是无法实现这些功能的，他没有那些获取构造器的方法等等。"></a>那么又回到反射的应用，就是使用”类的类”这个特点来编写一个工具，这个工具干什么呢？使用上面的例子来说明，我们编写这个依赖注入容器（这就是工具）的时候，不知道会传入些什么类，所以我们使用反射，也就是字节码对象来动态获取未知的类（好像类的变量），获取这个类以后，我们调用这个类的构造器创建一个对象然后返回这个对象。Object类是无法实现这些功能的，他没有那些获取构造器的方法等等。</h5><h5 id="理解动态获取类："><a href="#理解动态获取类：" class="headerlink" title="理解动态获取类："></a>理解动态获取类：</h5><p>​	在Java中，通常我们编写代码时，编译器需要知道所有类型信息，以便在编译时检查类型安全和访问权限。这意味着，如果我们想要创建一个对象、调用一个方法或访问一个字段，编译器需要能够看到相关的类定义。然而，反射提供了一种机制，允许我们在运行时而不是编译时获取和操作类的信息。这里的类型信息是在编译时就确定的。但是，使用反射，我们可以在运行时决定要操作的类型，也就是再运行时才会传入类型的信息，这个时候才能确定。</p>
<h4 id="四、23种设计模式"><a href="#四、23种设计模式" class="headerlink" title="四、23种设计模式"></a>四、23种设计模式</h4><h5 id="前言：接触了一下设计模式，感觉有点抽象，所以我准备慢慢学习这些设计模式"><a href="#前言：接触了一下设计模式，感觉有点抽象，所以我准备慢慢学习这些设计模式" class="headerlink" title="前言：接触了一下设计模式，感觉有点抽象，所以我准备慢慢学习这些设计模式"></a>前言：接触了一下设计模式，感觉有点抽象，所以我准备慢慢学习这些设计模式</h5><h5 id="使用设计模式的目的："><a href="#使用设计模式的目的：" class="headerlink" title="使用设计模式的目的："></a>使用设计模式的目的：</h5><p>​	为了可重用代码，提高代码的可扩展性和可维护性。学习设计模式有助于我们开发可维护，可拓展，低耦合，复用性高的代码</p>
<h5 id="开闭原则："><a href="#开闭原则：" class="headerlink" title="开闭原则："></a>开闭原则：</h5><p>​	软件对拓展开放，对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功	能，那是最好的。</p>
<h5 id="里氏替换原则："><a href="#里氏替换原则：" class="headerlink" title="里氏替换原则："></a>里氏替换原则：</h5><p>​	这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p>
<h5 id="创建型模式："><a href="#创建型模式：" class="headerlink" title="创建型模式："></a>创建型模式：</h5><p>​	创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>
<h5 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h5><h5 id="1、工厂方法："><a href="#1、工厂方法：" class="headerlink" title="1、工厂方法："></a>1、工厂方法：</h5><p>​	工厂模式最主要解决的问题就是创建者和调用者的耦合，那么代码层面其实就是取消对new的使用。使用工厂接口Factory和实现这个接口的 某个类的工厂比如CatFactory（生产猫的工厂类）来构造某个类，而不直接使用构造器。这样做的好处是什么呢？看一个具体的场景：</p>
<p>假设你正在开发一个应用程序，需要连接到不同类型的数据库（例如MySQL、PostgreSQL、Oracle等）。每种数据库的连接方式可能略有不同，并且连接参数（如用户名、密码、服务器地址等）可能也不同。</p>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>如果直接在客户端代码中创建数据库连接，那么每当需要支持一个新的数据库类型时，你就需要修改客户端代码来添加新的连接逻辑，这违反了开闭原则。</p>
<h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>使用工厂模式来封装数据库连接的创建过程。</p>
<h5 id="也就是说，在构建一个数据库连接类时，我们不使用它的构造器来构建它，而是使用它的工厂类来生产它（工厂类里调用这个类的构造器来生产），这样当我们要添加新的数据库连接类型的时候，比如原本我不用Oracle，现在要使用Oracle了，如果你使用的是构造器来实现的这个数据库连接逻辑，那么必然会对客户端代码逻辑进行修改，这就违反了开闭原则，而如果使用的是工厂模式，你只需要再实现一个Oracle的工厂类就行了，不必对客户端代码进行修改，就做到了了对拓展开放，对修改关闭。看一下二者的区别："><a href="#也就是说，在构建一个数据库连接类时，我们不使用它的构造器来构建它，而是使用它的工厂类来生产它（工厂类里调用这个类的构造器来生产），这样当我们要添加新的数据库连接类型的时候，比如原本我不用Oracle，现在要使用Oracle了，如果你使用的是构造器来实现的这个数据库连接逻辑，那么必然会对客户端代码逻辑进行修改，这就违反了开闭原则，而如果使用的是工厂模式，你只需要再实现一个Oracle的工厂类就行了，不必对客户端代码进行修改，就做到了了对拓展开放，对修改关闭。看一下二者的区别：" class="headerlink" title="也就是说，在构建一个数据库连接类时，我们不使用它的构造器来构建它，而是使用它的工厂类来生产它（工厂类里调用这个类的构造器来生产），这样当我们要添加新的数据库连接类型的时候，比如原本我不用Oracle，现在要使用Oracle了，如果你使用的是构造器来实现的这个数据库连接逻辑，那么必然会对客户端代码逻辑进行修改，这就违反了开闭原则，而如果使用的是工厂模式，你只需要再实现一个Oracle的工厂类就行了，不必对客户端代码进行修改，就做到了了对拓展开放，对修改关闭。看一下二者的区别："></a>也就是说，在构建一个数据库连接类时，我们不使用它的构造器来构建它，而是使用它的工厂类来生产它（工厂类里调用这个类的构造器来生产），这样当我们要添加新的数据库连接类型的时候，比如原本我不用Oracle，现在要使用Oracle了，如果你使用的是构造器来实现的这个数据库连接逻辑，那么必然会对客户端代码逻辑进行修改，这就违反了开闭原则，而如果使用的是工厂模式，你只需要再实现一个Oracle的工厂类就行了，不必对客户端代码进行修改，就做到了了对拓展开放，对修改关闭。看一下二者的区别：</h5><p>假设我们使用构造器实现，客户端代码可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (dbType.equals(&quot;MySQL&quot;)) &#123;</span><br><span class="line">    connection = new MySQLConnection();//连接的构造器</span><br><span class="line">&#125; else if (dbType.equals(&quot;PostgreSQL&quot;)) &#123;</span><br><span class="line">    connection = new PostgreSQLConnection();</span><br><span class="line">&#125; // 随着新类型的添加，这里需要不断增加else if分支</span><br></pre></td></tr></table></figure>

<p>现在，如果我们要添加一个新的数据库类型”SQLite”，我们需要在客户端代码中添加一个新的else if分支。</p>
<p>如果我们使用工厂模式，客户端代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatabaseConnectionFactory factory = getFactoryByDbType(dbType);//通过dbtype获取对应的工厂类</span><br><span class="line">DatabaseConnection connection = factory.createConnection();//使用这个工厂类构建这个类</span><br></pre></td></tr></table></figure>

<p>其中<code>getFactoryByDbType</code>是一个辅助方法，根据<code>dbType</code>返回相应的工厂实例。添加新的数据库类型时，我们只需要添加新的工厂类和在<code>getFactoryByDbType</code>中添加新的逻辑，而客户端代码不需要修改。</p>
<p>就是这样，嗯。</p>
<h5 id="结构型模式："><a href="#结构型模式：" class="headerlink" title="结构型模式："></a>结构型模式：</h5><h5 id="1、适配器（Adapter）模式。"><a href="#1、适配器（Adapter）模式。" class="headerlink" title="1、适配器（Adapter）模式。"></a>1、适配器（Adapter）模式。</h5><p><strong>场景描述：</strong>当你要使用一个方法，要传入一个a1接口的类，但是你现在要传入的参数是b1接口的类，并且这个b1的接口是不能改变的因为别的地方也会调用b1这个接口的类。大白话就是，如果去美国，我们随身带的电器是无法直接使用的，因为美国的插座标准和中国不同，所以，我们需要一个适配器，一头是可以连接美国插座的插头，一头是可以连接我们自己充电器口的插口。看一下案例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Task implements Callable&lt;Long&gt; &#123;</span><br><span class="line">    private long num;</span><br><span class="line">    public Task(long num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long call() throws Exception &#123;</span><br><span class="line">        long r = 0;</span><br><span class="line">        for (long n = 1; n &lt;= this.num; n++) &#123;</span><br><span class="line">            r = r + n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Result: &quot; + r);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Callable&lt;Long&gt; callable = new Task(123450000L);</span><br><span class="line">Thread thread = new Thread(callable); // 报错，要传入一个runnable接口</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">//我们不能更改callable接口，所以这样：</span><br><span class="line">Callable&lt;Long&gt; callable = new Task(123450000L);</span><br><span class="line">Thread thread = new Thread(new RunnableAdapter(callable));</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">//RunnableAdapter就是一个适配器，传入callable，返回runnabl</span><br><span class="line">//适配器这样写:</span><br><span class="line">public class RunnableAdapter implements Runnable &#123;</span><br><span class="line">    // 引用待转换接口:</span><br><span class="line">    private Callable&lt;?&gt; callable;</span><br><span class="line"></span><br><span class="line">    public RunnableAdapter(Callable&lt;?&gt; callable) &#123;</span><br><span class="line">        this.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现指定接口:</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 将指定接口调用委托给转换接口调用:</span><br><span class="line">        try &#123;</span><br><span class="line">            callable.call();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编写一个Adapter的步骤如下："><a href="#编写一个Adapter的步骤如下：" class="headerlink" title="编写一个Adapter的步骤如下："></a>编写一个Adapter的步骤如下：</h5><ol>
<li>实现目标接口，这里是<code>Runnable</code>；</li>
<li>内部持有一个待转换接口的引用，这里是通过字段持有<code>Callable</code>接口；</li>
<li>在目标接口的实现方法内部，调用待转换接口的方法。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/Java%20EE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/Java%20EE/" class="post-title-link" itemprop="url">JavaEE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:18:19" itemprop="dateModified" datetime="2024-11-20T21:18:19+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h1><h3 id="Web底层、Tomcat、Servlet，mybatis、Spring，SpringMVC、SpringBoot"><a href="#Web底层、Tomcat、Servlet，mybatis、Spring，SpringMVC、SpringBoot" class="headerlink" title="Web底层、Tomcat、Servlet，mybatis、Spring，SpringMVC、SpringBoot"></a>Web底层、Tomcat、Servlet，mybatis、Spring，SpringMVC、SpringBoot</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/SSM%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/SSM%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">SSM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:19:51" itemprop="dateModified" datetime="2024-11-20T21:19:51+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h1><p>尚硅谷的SSMu框架的课件：<a target="_blank" rel="noopener" href="https://www.wolai.com/v5Kuct5ZtPeVBk4NBUGBWF">快速掌握：全新SSM+Spring Boot+MyBatis-Plus实战精讲 (wolai.com)</a></p>
<p>源码的远程仓库：<a target="_blank" rel="noopener" href="https://github.com/SoulSend/Spring">SoulSend&#x2F;Spring: 学习SpringIoc容器和id的代码仓库 (github.com)</a></p>
<h3 id="Spring-framework"><a href="#Spring-framework" class="headerlink" title="Spring framework"></a>Spring framework</h3><h4 id="介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）"><a href="#介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）" class="headerlink" title="介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）"></a>介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）</h4><p><strong>控制反转：</strong>就是将创建对象的权力交给容器，我们开发者就不用创建对象了，让容器给我们创建和管理对象。</p>
<p><strong>依赖注入：</strong>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p>
<p><strong>容器</strong>：有简单容器和复杂容器，简单容器就只有存储功能如：数组；复杂容器不仅有存储功能还有管理存储的内容的功能</p>
<p><strong>组件：</strong>组件就是一个可重复利用的对象，这个对象一般再容器里是单例的</p>
<p><strong>框架：</strong>框架和工具的区别：工具就是一个jar包，它是写死的，你只能这么用。而框架是：jar包加上配置文件，也就是说，框架可以根据配置文件来动态的改变功能，这就是他们俩的区别</p>
<h4 id="使用XML配置IOC容器的ioc-di"><a href="#使用XML配置IOC容器的ioc-di" class="headerlink" title="使用XML配置IOC容器的ioc&#x2F;di"></a>使用XML配置IOC容器的ioc&#x2F;di</h4><h5 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h5><ul>
<li><p>先编写你需要放入ioc容器的类</p>
</li>
<li><p>兴建一个xml文件，如果你已经导入spring框架，在idea中可以快捷建立一个XML配置文件，然后选中Spring配置文件就可以快速生成一个自带spring标签约束的xml文件</p>
</li>
<li><p>然后在xml文件中使用 <bean> 标签配置你要放入容器的类案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 导入外部属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置 JdbcTemplate --&gt;</span><br><span class="line">    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">        &lt;!-- 装配数据源 --&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentDao&quot; class=&quot;com.atguigu.dao.impl.StudentDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentService&quot; class=&quot;com.atguigu.service.impl.StudentServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentController&quot; class=&quot;com.atguigu.controller.StudentController&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>id 属性是你放入的bean对象在ioc容器中唯一标识，在依赖注入时会用到</p>
</li>
<li><p>class 是目标类的全类名</p>
</li>
<li><p>当然，你可以指定一个bean对象的构造方法：构造器，工厂，这时的标签属性会有不同，可以看我远程仓库里的源码</p>
</li>
<li><p>打开bean标签里面，这个是di的配置，property是setter方法进行注入，name是setter方法去掉set，然后首字母小写的方法名字，value指定的是一个值，ref指定的是一个bean对象，这两个是setter方法的参数</p>
</li>
<li><p>然后就可以初始化一个ioc容器，获取bean对象了</p>
<p>更具体可以查看课件和源码。</p>
</li>
</ul>
<h4 id="使用注解配置ioc容器"><a href="#使用注解配置ioc容器" class="headerlink" title="使用注解配置ioc容器"></a>使用注解配置ioc容器</h4><h5 id="使用步骤：-1"><a href="#使用步骤：-1" class="headerlink" title="使用步骤："></a>使用步骤：</h5><ul>
<li><p>准备你要放入容器的类</p>
</li>
<li><p>在不同的项目层面会有不同的注解，功能都是一模一样的，仅仅只是名字不一样，为了方便程序员标识不同的项目层次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component：该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</span><br><span class="line"></span><br><span class="line">@Repository：该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</span><br><span class="line"></span><br><span class="line">@Service|该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</span><br><span class="line"></span><br><span class="line">@Controller：该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>将注解放到对应的项目层次</p>
</li>
<li><p>配置包扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置自动扫描的包 --&gt;</span><br><span class="line">    &lt;!-- 1.包要精准,提高性能!</span><br><span class="line">         2.会扫描指定的包和子包内容</span><br><span class="line">         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.atguigu.components&quot;/&gt;</span><br><span class="line">&lt;!-- 情况三：指定不扫描的组件 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.atguigu.components&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;</span><br><span class="line">    &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt;</span><br><span class="line">    &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt;</span><br><span class="line">    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 情况四：仅扫描指定的组件 --&gt;</span><br><span class="line">&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;</span><br><span class="line">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.atguigu.ioc.components&quot; use-default-filters=&quot;false&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;</span><br><span class="line">    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ioc容器内部的bean类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。</p>
</li>
</ul>
<h5 id="你可在注解后面指定value属性来设置bean的类名"><a href="#你可在注解后面指定value属性来设置bean的类名" class="headerlink" title="你可在注解后面指定value属性来设置bean的类名"></a>你可在注解后面指定value属性来设置bean的类名</h5>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/Java%E8%A1%8C%E4%B8%9A%E5%8F%91%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/Java%E8%A1%8C%E4%B8%9A%E5%8F%91%E5%B1%95/" class="post-title-link" itemprop="url">java行业发展</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:19:24" itemprop="dateModified" datetime="2024-11-20T21:19:24+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java行业发展"><a href="#Java行业发展" class="headerlink" title="Java行业发展"></a>Java行业发展</h1><h3 id="一、关于哪些java不好就业的说法"><a href="#一、关于哪些java不好就业的说法" class="headerlink" title="一、关于哪些java不好就业的说法"></a>一、关于哪些java不好就业的说法</h3><p>基础不扎实的人在制造焦虑减少竞争，基础不扎实，啥工作都不好找。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/javaWeb%E5%8E%9F%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/javaWeb%E5%8E%9F%E7%94%9F/" class="post-title-link" itemprop="url">JavaWeb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:18:38" itemprop="dateModified" datetime="2024-11-20T21:18:38+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="javaWeb原生"><a href="#javaWeb原生" class="headerlink" title="javaWeb原生"></a>javaWeb原生</h1><h2 id="前言：了解原生web是如何编写的，有助于理解学习现在更好的技术"><a href="#前言：了解原生web是如何编写的，有助于理解学习现在更好的技术" class="headerlink" title="前言：了解原生web是如何编写的，有助于理解学习现在更好的技术"></a>前言：了解原生web是如何编写的，有助于理解学习现在更好的技术</h2><h4 id="一、使用Java原生的API编写一个javaweb的服务器，响应客户端的请求："><a href="#一、使用Java原生的API编写一个javaweb的服务器，响应客户端的请求：" class="headerlink" title="一、使用Java原生的API编写一个javaweb的服务器，响应客户端的请求："></a>一、使用Java原生的API编写一个javaweb的服务器，响应客户端的请求：</h4><p>​	看看这个博客的文章URL：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304265903570978">Web基础 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。它上面写的就是如何使用java自带的API编写一个基础的服务器。第一次观看完以后，我觉得对于底层的服务器实现有了一个较为清晰的认识，其实就是先使用套接字监听服务器的某个端口，一旦端口接收到来自浏览器的HTTP请求，就创建一个线程来处理这个请求。在这个线程当中通过套接字获取这个请求的输入输出流，然后通过输入流获取HTML，然后进行处理比如：读取请求路径请求头，然后通过输出流返回一个响应就可以了。就是这么简单粗暴。</p>
<h4 id="二、Servlet入门"><a href="#二、Servlet入门" class="headerlink" title="二、Servlet入门"></a>二、Servlet入门</h4><p>​	<strong>我们使用Servlet API编写自己的Servlet来处理HTTP请求，Web服务器实现Servlet API接口。</strong>servlet就是一个API，这个API封装和提供了网页的请求和响应，我们直接就可以使用这些接口获取到HTTP的请求和响应，然后通过输入输出流完成服务器的逻辑操作。但是这个servlet需要运行在可以满足servlet的web服务器程序上，就是上面编写的那种服务器，不过这个web服务器写的更好更完善。以web服务器tomcat为例：当我们把servlet使用maven打成war包后部署到tomcat上，启动tomcat服务器其实就是启动jvm执行tomcat的main（）方法，然后main方法里面的逻辑就会生成一个部署在服务器上的servlet的单例，最后以多线程的模式来处理HTTP请求。这个tomcat服务器叫做web服务器，因为它可以用来放servlet程序，也叫他为servlet容器。文章URL：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304265949708322">Servlet入门 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。</p>
<h5 id="1、这里我仅仅简单的了解了servlet，并不知道底层是如何实现的，也就是我们是怎么通过servlet就可以获取到前端的请求的呢？tomcat又是怎么执行我们所实现的servlet的呢？"><a href="#1、这里我仅仅简单的了解了servlet，并不知道底层是如何实现的，也就是我们是怎么通过servlet就可以获取到前端的请求的呢？tomcat又是怎么执行我们所实现的servlet的呢？" class="headerlink" title="1、这里我仅仅简单的了解了servlet，并不知道底层是如何实现的，也就是我们是怎么通过servlet就可以获取到前端的请求的呢？tomcat又是怎么执行我们所实现的servlet的呢？"></a>1、<strong>这里我仅仅简单的了解了servlet</strong>，并不知道底层是如何实现的，也就是我们是怎么通过servlet就可以获取到前端的请求的呢？tomcat又是怎么执行我们所实现的servlet的呢？</h5><p>​	通过百度：首先，HTTP请求（包括请求方法、请求头和实体数据）通过socket传输到服务器。当Tomcat接收到一个HTTP请求时，它会解析请求数据并创建一个请求对象。接着，根据请求的URL和协议&#x2F;版本等信息，Tomcat会找到相应的处理方法（通常是一个Servlet的doGet、doPost等方法）。然后，使用Java反射机制，Tomcat会实例化相应的Servlet类并调用相应的方法。最后，处理结果会被封装成HTTP响应并通过socket返回给客户端。文章url：<a target="_blank" rel="noopener" href="https://developer.baidu.com/article/detail.html?id=2891840">深入剖析Tomcat：底层实现原理与应用-百度开发者中心 (baidu.com)</a>。</p>
<h4 id="三、servlet开发"><a href="#三、servlet开发" class="headerlink" title="三、servlet开发"></a>三、servlet开发</h4><p>​	文章URL：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266264743830016">Servlet开发 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。这篇文章教你如何方便快捷的调试部署的servlet程序。就是将tomcat的jar包引入到当前项目，然后通过自己编写main方法的逻辑来部署相应的webapp和启动tomcat。</p>
<h4 id="四、servlet进阶"><a href="#四、servlet进阶" class="headerlink" title="四、servlet进阶"></a>四、servlet进阶</h4><p>​	文章URL：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1328705066500130">Servlet进阶 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。这篇文章讲解了HttpServletRequest和HttpServletResponse的使用和服务器处理请求的流程。一个webapp上可以部署多个servlet程序，通过@webservlet注解映射这个servlet处理的路径。web服务器会接收前端的请求然后根据请求路径将这些请求分发给对应的servlet处理。</p>
<h5 id="1、重定向与转发"><a href="#1、重定向与转发" class="headerlink" title="1、重定向与转发"></a>1、重定向与转发</h5><p>​	文章路径：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1328761739935778">重定向与转发 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。Redirect：重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。Forward：Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。</p>
<h5 id="2、使用Session和Cookie"><a href="#2、使用Session和Cookie" class="headerlink" title="2、使用Session和Cookie"></a>2、使用Session和Cookie</h5><p>​	文章路径：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1328768897515553">使用Session和Cookie - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。基于唯一ID识别用户身份的机制称为Session，session是一种机制，cookie是一种实现这种机制的技术。</p>
<h4 id="五、jsp开发"><a href="#五、jsp开发" class="headerlink" title="五、jsp开发"></a>五、jsp开发</h4><p>​	文章路径：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266262958498784">JSP开发 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。使用servlet来返回一个http格式的文件很麻烦，所以我们将这个渲染返回http文件的事情交给jsp来做，要交给别人来做就要使用变量，所以jsp有自带的变量来接受来自servlet的数据，然后使用这些变量名来访问这些数据，然后渲染</p>
<h4 id="六、MVC开发"><a href="#六、MVC开发" class="headerlink" title="六、MVC开发"></a>六、MVC开发</h4><p>​	文章路径：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266264917931808">MVC开发 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。Servlet适合编写Java代码，实现各种复杂的业务逻辑，但不适合输出复杂的HTML；JSP适合编写HTML，并在其中插入动态内容，但不适合编写复杂的Java代码。将两者结合起来，发挥各自的优点，避免各自的缺点就是MVC开发</p>
<h4 id="七、Filter拦截器"><a href="#七、Filter拦截器" class="headerlink" title="七、Filter拦截器"></a>七、Filter拦截器</h4><p>​	文章路径：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266264823560128">使用Filter - 廖雪峰的官方网站 (liaoxuefeng.com)</a>.filter拦截器工作在servlet之前，所以它是服务器外面的组件。</p>
<h4 id="八、listener"><a href="#八、listener" class="headerlink" title="八、listener"></a>八、listener</h4><p>​	文章路径：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304266123771937">使用Listener - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。通过Listener我们可以监听Web应用程序的生命周期，获取<code>HttpSession</code>等创建和销毁的事件；</p>
<h4 id="九、部署"><a href="#九、部署" class="headerlink" title="九、部署"></a>九、部署</h4><p>​	文章路径：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304266260086817">部署 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>。把静态网页资源部署到前端服务器nginx，让这个服务器处理静态资源的请求和处理。然后把servlet等逻辑处理程序部署到tomcat这样的web服务器里，这样就方便维护</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/Spring/" class="post-title-link" itemprop="url">spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:19:02" itemprop="dateModified" datetime="2024-11-20T21:19:02+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h1><p>尚硅谷的SSMu框架的课件：<a target="_blank" rel="noopener" href="https://www.wolai.com/v5Kuct5ZtPeVBk4NBUGBWF">快速掌握：全新SSM+Spring Boot+MyBatis-Plus实战精讲 (wolai.com)</a></p>
<p>源码的远程仓库：<a target="_blank" rel="noopener" href="https://github.com/SoulSend/Spring">SoulSend&#x2F;Spring: 学习SpringIoc容器和id的代码仓库 (github.com)</a></p>
<h2 id="Spring-framework"><a href="#Spring-framework" class="headerlink" title="Spring framework"></a>Spring framework</h2><h4 id="介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）"><a href="#介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）" class="headerlink" title="介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）"></a>介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）</h4><p><strong>控制反转：</strong>就是将创建对象的权力交给容器，我们开发者就不用创建对象了，让容器给我们创建和管理对象。</p>
<p><strong>依赖注入：</strong>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p>
<p><strong>容器</strong>：有简单容器和复杂容器，简单容器就只有存储功能如：数组；复杂容器不仅有存储功能还有管理存储的内容的功能</p>
<p><strong>组件：</strong>组件就是一个可重复利用的对象，这个对象一般再容器里是单例的</p>
<p><strong>框架：</strong>框架和工具的区别：工具就是一个jar包，它是写死的，你只能这么用。而框架是：jar包加上配置文件，也就是说，框架可以根据配置文件来动态的改变功能，这就是他们俩的区别</p>
<h4 id="使用XML配置IOC容器的ioc-di"><a href="#使用XML配置IOC容器的ioc-di" class="headerlink" title="使用XML配置IOC容器的ioc&#x2F;di"></a>使用XML配置IOC容器的ioc&#x2F;di</h4><h5 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h5><ul>
<li><p>先编写你需要放入ioc容器的类</p>
</li>
<li><p>兴建一个xml文件，如果你已经导入spring框架，在idea中可以快捷建立一个XML配置文件，然后选中Spring配置文件就可以快速生成一个自带spring标签约束的xml文件</p>
</li>
<li><p>然后在xml文件中使用 <bean> 标签配置你要放入容器的类案例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 导入外部属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;atguigu.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;atguigu.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;atguigu.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;atguigu.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 JdbcTemplate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 装配数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.dao.impl.StudentDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbcTemplate&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.service.impl.StudentServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studentDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;studentDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.controller.StudentController&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;studentService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>id 属性是你放入的bean对象在ioc容器中唯一标识，在依赖注入时会用到</p>
</li>
<li><p>class 是目标类的全类名</p>
</li>
<li><p>当然，你可以指定一个bean对象的构造方法：构造器，工厂，这时的标签属性会有不同，可以看我远程仓库里的源码</p>
</li>
<li><p>打开bean标签里面，这个是di的配置，property是setter方法进行注入，name是setter方法去掉set，然后首字母小写的方法名字，value指定的是一个值，ref指定的是一个bean对象，这两个是setter方法的参数</p>
</li>
<li><p>然后就可以初始化一个ioc容器，获取bean对象了</p>
<p>更具体可以查看课件和源码。</p>
</li>
</ul>
<h4 id="使用注解配置ioc容器"><a href="#使用注解配置ioc容器" class="headerlink" title="使用注解配置ioc容器"></a>使用注解配置ioc容器</h4><h4 id="ioc配置使用步骤："><a href="#ioc配置使用步骤：" class="headerlink" title="ioc配置使用步骤："></a>ioc配置使用步骤：</h4><ul>
<li><p>准备你要放入容器的类</p>
</li>
<li><p>在不同的项目层面会有不同的注解，功能都是一模一样的，仅仅只是名字不一样，为了方便程序员标识不同的项目层次：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component：该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</span><br><span class="line"></span><br><span class="line">@Repository：该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</span><br><span class="line"></span><br><span class="line">@Service|该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</span><br><span class="line"></span><br><span class="line">@Controller：该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>将注解放到对应的项目层次</p>
</li>
<li><p>配置包扫描</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自动扫描的包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.包要精准,提高性能!</span></span><br><span class="line"><span class="comment">         2.会扫描指定的包和子包内容</span></span><br><span class="line"><span class="comment">         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.components&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 情况三：指定不扫描的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.components&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- context:exclude-filter标签：指定排除规则 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 情况四：仅扫描指定的组件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.ioc.components&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ioc容器内部的bean类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。</p>
</li>
</ul>
<h5 id="你可在注解后面指定value属性来设置bean的类名"><a href="#你可在注解后面指定value属性来设置bean的类名" class="headerlink" title="你可在注解后面指定value属性来设置bean的类名"></a>你可在注解后面指定value属性来设置bean的类名</h5><h5 id="引用DI配置步骤"><a href="#引用DI配置步骤" class="headerlink" title="引用DI配置步骤:"></a>引用DI配置步骤:</h5><ul>
<li>将你要注入的所有类装配进入ioc容器</li>
<li>在你要注入的属性上面添加@Autowired注解</li>
</ul>
<h5 id="注解流程："><a href="#注解流程：" class="headerlink" title="注解流程："></a>注解流程：</h5><ul>
<li>首先根据所需要的<strong>组件类型</strong>到 IOC 容器中查找</li>
<li>能够找到唯一的 bean：直接执行装配</li>
<li>如果完全找不到匹配这个类型的 bean：装配失败</li>
<li>和所需类型匹配的 bean 不止一个<ul>
<li>没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
<li>使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果注解下是一个接口，接口有多个实现类就会出现多个bean对象的异常抛出</p>
<h5 id="扩展JSR-250注解-Resource，这个注解就相当于：-Autowired-Qualifier"><a href="#扩展JSR-250注解-Resource，这个注解就相当于：-Autowired-Qualifier" class="headerlink" title="扩展JSR-250注解@Resource，这个注解就相当于：@Autowired + @Qualifier"></a>扩展JSR-250注解@Resource，这个注解就相当于：@Autowired + @Qualifier</h5><h5 id="基本类型DI配置："><a href="#基本类型DI配置：" class="headerlink" title="基本类型DI配置："></a>基本类型DI配置：</h5><ul>
<li><p>1、直接将值赋给基础类型</p>
</li>
<li><p>2、使用value可以获取外部配置文件里的值，但是需要在xml文件里读取外部配置文件，然后使用value注解获取配置文件里的值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--读取配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;value.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">@Value(&quot;$&#123;value.username&#125;&quot;)</span><br><span class="line">    private  String username;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="配置类（完全注解开发）"><a href="#配置类（完全注解开发）" class="headerlink" title="配置类（完全注解开发）"></a>配置类（完全注解开发）</h4><h5 id="使用配置类来代替XMl配置文件，用注解-Configuration来标注。在配置类里使用注解来配置ioc和di这样就脱离了xml配置文件，达成完全注解开发的目的"><a href="#使用配置类来代替XMl配置文件，用注解-Configuration来标注。在配置类里使用注解来配置ioc和di这样就脱离了xml配置文件，达成完全注解开发的目的" class="headerlink" title="使用配置类来代替XMl配置文件，用注解@Configuration来标注。在配置类里使用注解来配置ioc和di这样就脱离了xml配置文件，达成完全注解开发的目的"></a>使用配置类来代替XMl配置文件，用注解@Configuration来标注。在配置类里使用注解来配置ioc和di这样就脱离了xml配置文件，达成完全注解开发的目的</h5><p>使用步骤：</p>
<p>先使用@Configuration标注这是一个配置类然后使用两个注解</p>
<p>@Componentscan是包扫描注解</p>
<p>@PropertySource是引用外部的配置文件</p>
<p>在配置类的内部，使用@bean标签来标注一个组件，这个注解放在一个方法上，方法的返回值就是bean的类型，方法名就是bean的id。在这个方法里使用你的方法，不管是构造器还是工厂类来构建一个bean对象，同时使用setter方法来进行初始化。</p>
<p>读取配置类以后，要使用变量装配配置文件里的值，可以先使用Value注解将值赋给一个普通变量，然后通过set方法传参将这个变量注入到对应的bean对象里</p>
<h5 id="Import注解的使用"><a href="#Import注解的使用" class="headerlink" title="@Import注解的使用"></a>@Import注解的使用</h5><p>@Import 注释允许从另一个配置类加载 @Bean 定义，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> B <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，在实例化上下文时不需要同时指定 ConfigA.class 和 ConfigB.class ，只需显式提供 ConfigB ，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigB.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// now both beans A and B will be available...</span></span><br><span class="line">  <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> ctx.getBean(A.class);</span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的 @Configuration 类。</p>
<h4 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h4><p><strong>使用场景：</strong>当一个类的很多个方法都要添加一个相同的逻辑功能的时候，如果我们依次为每个方法添加，这样的效率非常低，且维护成本高，且代码耦合度也很高，这时我们你想了一个办法，将相同的逻辑提炼出来，当调用一个方法的时候，将这个提炼出来的逻辑动态的加入到这个方法中，这个就是AOP面向切面编程。</p>
<h5 id="代理模式：类似房客—–中介—–房东的关系，我们把一个方法的核心逻辑提取出来，非核心逻辑（日志之类的）放到代理类里。这样做的好处："><a href="#代理模式：类似房客—–中介—–房东的关系，我们把一个方法的核心逻辑提取出来，非核心逻辑（日志之类的）放到代理类里。这样做的好处：" class="headerlink" title="代理模式：类似房客—–中介—–房东的关系，我们把一个方法的核心逻辑提取出来，非核心逻辑（日志之类的）放到代理类里。这样做的好处："></a>代理模式：类似房客—–中介—–房东的关系，我们把一个方法的核心逻辑提取出来，非核心逻辑（日志之类的）放到代理类里。这样做的好处：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代理模式提供了一种结构化的方法来处理这些逻辑，使得代码更加模块化和易于管理。此外，代理模式允许在不修改目标对象的情况下，通过修改代理类来添加或更改非核心逻辑，这在某些情况下可以大大简化开发和维护工作。</span><br></pre></td></tr></table></figure>

<p><strong>静态代理：</strong>核心逻辑放到目标类的里面，然后代理类拥有一个目标类，我们直接调用代理类的对应的方法，在代理类里面，先有代理类执行非核心逻辑，再由代理类调用本身拥有的目标类的方法，执行核心逻辑。就是这么简单。具体实现查看代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补充说明：静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。</span><br><span class="line">提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</span><br></pre></td></tr></table></figure>

<p><strong>动态代理：</strong>动态代理是一种在运行时动态创建代理对象的代理模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动态代理技术分类</span><br><span class="line">- JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须**实现接口**！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子）</span><br><span class="line">- cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）</span><br></pre></td></tr></table></figure>



<h5 id="AOP是一种编程思想，是对面向对象编程思想OOP的一种完善，我们使用动态代理的技术来实现AOP。AOP的思想就是将非核心逻辑提取出来成为一个切面，使用动态代理的技术，当我们调用目标类的某一个方法的时候，会将这个切片插入到这个方法里，形成一个代理方法，最后执行的就是这个代理方法"><a href="#AOP是一种编程思想，是对面向对象编程思想OOP的一种完善，我们使用动态代理的技术来实现AOP。AOP的思想就是将非核心逻辑提取出来成为一个切面，使用动态代理的技术，当我们调用目标类的某一个方法的时候，会将这个切片插入到这个方法里，形成一个代理方法，最后执行的就是这个代理方法" class="headerlink" title="AOP是一种编程思想，是对面向对象编程思想OOP的一种完善，我们使用动态代理的技术来实现AOP。AOP的思想就是将非核心逻辑提取出来成为一个切面，使用动态代理的技术，当我们调用目标类的某一个方法的时候，会将这个切片插入到这个方法里，形成一个代理方法，最后执行的就是这个代理方法"></a>AOP是一种编程思想，是对面向对象编程思想OOP的一种完善，我们使用动态代理的技术来实现AOP。AOP的思想就是将非核心逻辑提取出来成为一个切面，使用动态代理的技术，当我们调用目标类的某一个方法的时候，会将这个切片插入到这个方法里，形成一个代理方法，最后执行的就是这个代理方法</h5><p><strong>总结一句话：</strong>AOP编程思想就是解决非核心业务代码冗余的问题的。大白话就是不重要的，但是所有方法都有的逻辑，将这个逻辑代码抽取成一个切片，然后动态分发给每一个方法。</p>
<h5 id="AOP编程思想的术语："><a href="#AOP编程思想的术语：" class="headerlink" title="AOP编程思想的术语："></a>AOP编程思想的术语：</h5><ul>
<li><strong>横切关注点</strong>：就是对非核心的哪些业务场景进行描述的一个术语，不然每次都说非核心业务很麻烦比如日志，事务哪些业务，与之相对的，核心代码业务就叫<strong>核心关注点</strong></li>
<li><strong>通知（增强）：</strong>就是前面说的切片，一个切片就是一个通知。也就是哪些提取出来的横切关注点的代码。每一个横切关注点上都要有一个方法来实现它，这个方法就是通知方法：<ul>
<li>前置通知：在被代理的目标类方法执行前的通知</li>
<li>返回通知：目标类的方法执行成功后执行的通知</li>
<li>异常通知：在目标类的方法执行出现异常的时候执行的通知</li>
<li>后置通知：目标类方法最终执行完毕后执行的通知</li>
<li>环绕通知：把目标方法包围的通知</li>
</ul>
</li>
<li><strong>连接点：</strong>目标类有很多方法，哪些方法要切入通知，哪些方法不需要切入通知，要切入通知的方法就是连接点，连接点就是用来标识我们通知的方法是哪个？是哪些方法需要切入通知。</li>
<li><strong>切入点：</strong>我们有多个连接点，被通知切入的连接点就是切入点</li>
<li><strong>切面：</strong>当我们的通知切入连接点以后就形成了一个切面</li>
<li><strong>目标：</strong>要被切入的对象或者说被代理的对象就是目标，前面的代理模式介绍过了</li>
<li><strong>代理：</strong>作为名词就是：目标类切入通知以后形成的代理类。作为动词就是：形成代理类的动作就叫代理</li>
<li><strong>织入：</strong>把通知应用到目标类上，生成代理类的过程就是织入，有静态织入和动态织入，其实就是静态代理和动态代理，spring用的是后者</li>
</ul>
<h5 id="Aop练习案例："><a href="#Aop练习案例：" class="headerlink" title="Aop练习案例："></a>Aop练习案例：</h5><ul>
<li><p>1、首先编写核心逻辑代码，将这些核心逻辑的类全部放入ioc容器</p>
</li>
<li><p>2、编写一个通知类，同时将这个类放入ioc容器，这个类里包含了你抽取出来的非核心逻辑，类上标注注解@Aspect，表明这是一个通知类</p>
</li>
<li><p>3、在通知类里编写具体的通知逻辑，根据通知的执行时间使用不同的注解</p>
</li>
<li><p>4、在注解内使用value属性，属性是一个字符串，字符串内写入execution(）这个方法，方法参数就是切入点表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Before(value = &quot;execution(* com.hrc.service.imp.CalculatorImp.add(int ,int))&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>5、开启spring的Aspect支持，在配置类上注解@EnableAspectJAutoProxy,或者xml配置文件编写&lt;aop:aspectj-autoproxy &#x2F;&gt;</p>
</li>
</ul>
<h5 id="1、在通知中获取目标类的方法信息"><a href="#1、在通知中获取目标类的方法信息" class="headerlink" title="1、在通知中获取目标类的方法信息"></a>1、在通知中获取目标类的方法信息</h5><p>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</p>
<ul>
<li>要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息）</li>
<li>要点2：通过目标方法签名对象获取方法名</li>
<li>要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组</li>
</ul>
<h5 id="2、方法返回值"><a href="#2、方法返回值" class="headerlink" title="2、方法返回值"></a>2、方法返回值</h5><p>在返回通知中，通过@AfterReturning注解的returning属性获取目标方法的返回值！</p>
<ul>
<li>在方法形参中声明你的返回值形参名字，在注解中给returning属性赋值你的形参名，这样就会将方法返回值封装给形参</li>
</ul>
<h5 id="3、异常对象捕捉"><a href="#3、异常对象捕捉" class="headerlink" title="3、异常对象捕捉"></a>3、异常对象捕捉</h5><p>在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象，使用方法同 2 一样</p>
<h5 id="AOP切点表达式"><a href="#AOP切点表达式" class="headerlink" title="AOP切点表达式"></a>AOP切点表达式</h5><p><strong>介绍：</strong>说白了就是一个通配字符串，用来匹配切点的</p>
<p><strong>语法</strong>:</p>
<ul>
<li>第一位：execution( ) 固定开头</li>
<li>第二位：方法访问修饰符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">private</span> 直接描述对应修饰符即可</span><br></pre></td></tr></table></figure>
<ul>
<li>第三位：方法返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> String <span class="keyword">void</span> 直接描述返回值类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>注意：

特殊情况 不考虑 访问修饰符和返回值

  execution(* * ) 这是错误语法

  execution(*) == 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了
</code></pre>
<ul>
<li>第四位：指定包的地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">固定的包: com.atguigu.api | service | dao</span><br><span class="line">单层的任意命名: com.atguigu.*  = com.atguigu.api  com.atguigu.dao  * = 任意一层的任意命名</span><br><span class="line">任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!</span><br><span class="line">注意: ..不能用作包开头   <span class="keyword">public</span> <span class="type">int</span> .. 错误语法  com..</span><br><span class="line">找到任何包下: *..</span><br></pre></td></tr></table></figure>
<ul>
<li>第五位：指定类名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">固定名称: UserService</span><br><span class="line">任意类名: *</span><br><span class="line">部分任意: com..service.impl.*Impl</span><br><span class="line">任意包任意类: *..*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>第六位：指定方法名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法和类名一致</span><br><span class="line">任意访问修饰符,任意类的任意方法: * *..*.*</span><br></pre></td></tr></table></figure>
<ul>
<li>第七位：方法参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第七位: 方法的参数描述</span><br><span class="line">       具体值: (String,<span class="type">int</span>) != (<span class="type">int</span>,String) 没有参数 ()</span><br><span class="line">       模糊值: 任意参数 有 或者 没有 (..)  ..任意参数的意识</span><br><span class="line">       部分具体和模糊:</span><br><span class="line">         第一个参数是字符串的方法 (String..)</span><br><span class="line">         最后一个参数是字符串 (..String)</span><br><span class="line">         字符串开头,<span class="type">int</span>结尾 (String..<span class="type">int</span>)</span><br><span class="line">         包含<span class="type">int</span>类型(..<span class="type">int</span>..)</span><br></pre></td></tr></table></figure>

<h5 id="切点表达式案例"><a href="#切点表达式案例" class="headerlink" title="切点表达式案例"></a>切点表达式案例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.查询某包某类下，访问修饰符是公有，返回值是int的全部方法</span><br><span class="line">2.查询某包下类中第一个参数是String的方法</span><br><span class="line">3.查询全部包下，无参数的方法！</span><br><span class="line">4.查询com包下，以int参数类型结尾的方法</span><br><span class="line">5.查询指定包下，Service开头类的私有返回值int的无参数方法</span><br></pre></td></tr></table></figure>

<h5 id="切点表达式的复用"><a href="#切点表达式的复用" class="headerlink" title="切点表达式的复用"></a>切点表达式的复用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、可以在定义一个方法，方法名返回值都随意，要无参。在方法上使用注解pointcut 属性calue值就是切点表达式，然后在其他通知方法的注解处将切点表达式修改为这个方法的调用就行</span><br><span class="line">2、创建一个存储切点的类，单独维护切点表达式，然后再通知类里调用这个切点表达式类的对应切点表达式方法</span><br></pre></td></tr></table></figure>

<h5 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h5><p>​	一个顶前面的所有通知，允许程序猿自己定义通知的位置，通过参数ProceedingJoinPoint 来获取目标方法，执行参数的proceed方法</p>
<h5 id="切面排序"><a href="#切面排序" class="headerlink" title="切面排序"></a>切面排序</h5><p>​	在切面类的上面添加注解@Order（数字），参数数字越小优先级越高，越高越先执行</p>
<h5 id="也可以使用XML来配置AOP"><a href="#也可以使用XML来配置AOP" class="headerlink" title="也可以使用XML来配置AOP"></a>也可以使用XML来配置AOP</h5><h5 id="注意事项：根据我们要使用切片的类有无接口来选择是使用jdk的aop还是使用cglib的aop。如果有接口使用jdk自带的，没有就用cglib，使用自带的jdkaop的时候，要使用接口来接收注入的bean否则会报错，因为底层的实现是根据这个接口实现一个类相当于目标类的兄弟类来代理的，而cglib是继承目标类的，可以使用目标类接收bean"><a href="#注意事项：根据我们要使用切片的类有无接口来选择是使用jdk的aop还是使用cglib的aop。如果有接口使用jdk自带的，没有就用cglib，使用自带的jdkaop的时候，要使用接口来接收注入的bean否则会报错，因为底层的实现是根据这个接口实现一个类相当于目标类的兄弟类来代理的，而cglib是继承目标类的，可以使用目标类接收bean" class="headerlink" title="注意事项：根据我们要使用切片的类有无接口来选择是使用jdk的aop还是使用cglib的aop。如果有接口使用jdk自带的，没有就用cglib，使用自带的jdkaop的时候，要使用接口来接收注入的bean否则会报错，因为底层的实现是根据这个接口实现一个类相当于目标类的兄弟类来代理的，而cglib是继承目标类的，可以使用目标类接收bean"></a>注意事项：根据我们要使用切片的类有无接口来选择是使用jdk的aop还是使用cglib的aop。如果有接口使用jdk自带的，没有就用cglib，使用自带的jdkaop的时候，要使用接口来接收注入的bean否则会报错，因为底层的实现是根据这个接口实现一个类相当于目标类的兄弟类来代理的，而cglib是继承目标类的，可以使用目标类接收bean</h5><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="编程式事务和声明式事务"><a href="#编程式事务和声明式事务" class="headerlink" title="编程式事务和声明式事务"></a>编程式事务和声明式事务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编程式事务要程序员自己编写事务代码，繁琐但自由</span><br><span class="line">声明式事务是框架提供给给程序员的，程序员只需要做好配置就可以直接使用</span><br></pre></td></tr></table></figure>

<h5 id="事务管理器和原理"><a href="#事务管理器和原理" class="headerlink" title="事务管理器和原理"></a>事务管理器和原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务也算是非核心代码，也就是横切关注点。我们可以使用AOP来实现事务的插入</span><br><span class="line">官方提供了一套事务管理器的接口，各个数据库的厂商自己实现自己的数据库的事务管理器，我们要是用哪个事务管理器，直接将对应的管理器放入ioc容器里面，然后在配置类里用@EnableTransactionManagement 打开spring1的事务支持就可以使用了事务了，怎么使用呢？在要添加事务的类或者方法上添加一个注解 @Transactional 它默认不采用只读，当我们要使用只读操作时可以设置onlyread为true。添加完注解时，spring为这个类创建一个aop创建一个代理，这个代理就有事务的代码和核心代码。</span><br><span class="line">事务管理器接口和事务管理器和关系就好像jdbc规范和数据库驱动一样</span><br><span class="line">原理我只是粗略的记录一番，如果忘记了还是要去课程的笔记看看</span><br></pre></td></tr></table></figure>

<h5 id="异常回滚：异常回滚默认回滚runtime异常，io异常不会回滚，所以可以配置注解属性rollbackfor为exception，这样就可以将两种异常都捕捉回滚了"><a href="#异常回滚：异常回滚默认回滚runtime异常，io异常不会回滚，所以可以配置注解属性rollbackfor为exception，这样就可以将两种异常都捕捉回滚了" class="headerlink" title="异常回滚：异常回滚默认回滚runtime异常，io异常不会回滚，所以可以配置注解属性rollbackfor为exception，这样就可以将两种异常都捕捉回滚了"></a>异常回滚：异常回滚默认回滚runtime异常，io异常不会回滚，所以可以配置注解属性rollbackfor为exception，这样就可以将两种异常都捕捉回滚了</h5><p><strong>事务隔离级别：</strong>避免事务并发导致数据不一致的问题使用isolation来设置隔离级<strong>别</strong></p>
<p><strong>事务传播行为：</strong>多个事务相互调用的时候，是加入还是不加入，在被调用的事务中声明</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/vue-admin-template%E6%A8%A1%E6%9D%BF%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/vue-admin-template%E6%A8%A1%E6%9D%BF%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">前端后台页面模板使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:20:18" itemprop="dateModified" datetime="2024-11-20T21:20:18+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vue-admin-template模板使用"><a href="#vue-admin-template模板使用" class="headerlink" title="vue-admin-template模板使用"></a>vue-admin-template模板使用</h1><h4 id="前言：关于vue-admin-template，这是一个最最基础的模板，它是vue-element-admin的骨架，我们使用这个骨架来丰富自己想要的具体功能。而vue-element-admin是具备非常丰富功能的一个完整的开发好的系统。我们个人开发一个小系统，不需要这么丰富的功能，所以我们使用vue-admin-template来开发我们自己的系统，想要什么功能我们可以直接去vue-element-admin的源码中把对应功能的代码复制粘贴就可以了。简单一句话：element是工具包，templeate要什么功能我们就去element找，找到就把对应功能的代码粘贴就完了，不过粘贴也有方法，会在后面详细说明。"><a href="#前言：关于vue-admin-template，这是一个最最基础的模板，它是vue-element-admin的骨架，我们使用这个骨架来丰富自己想要的具体功能。而vue-element-admin是具备非常丰富功能的一个完整的开发好的系统。我们个人开发一个小系统，不需要这么丰富的功能，所以我们使用vue-admin-template来开发我们自己的系统，想要什么功能我们可以直接去vue-element-admin的源码中把对应功能的代码复制粘贴就可以了。简单一句话：element是工具包，templeate要什么功能我们就去element找，找到就把对应功能的代码粘贴就完了，不过粘贴也有方法，会在后面详细说明。" class="headerlink" title="前言：关于vue-admin-template，这是一个最最基础的模板，它是vue-element-admin的骨架，我们使用这个骨架来丰富自己想要的具体功能。而vue-element-admin是具备非常丰富功能的一个完整的开发好的系统。我们个人开发一个小系统，不需要这么丰富的功能，所以我们使用vue-admin-template来开发我们自己的系统，想要什么功能我们可以直接去vue-element-admin的源码中把对应功能的代码复制粘贴就可以了。简单一句话：element是工具包，templeate要什么功能我们就去element找，找到就把对应功能的代码粘贴就完了，不过粘贴也有方法，会在后面详细说明。"></a>前言：关于vue-admin-template，这是一个最最基础的模板，它是vue-element-admin的骨架，我们使用这个骨架来丰富自己想要的具体功能。而vue-element-admin是具备非常丰富功能的一个完整的开发好的系统。我们个人开发一个小系统，不需要这么丰富的功能，所以我们使用vue-admin-template来开发我们自己的系统，想要什么功能我们可以直接去vue-element-admin的源码中把对应功能的代码复制粘贴就可以了。简单一句话：element是工具包，templeate要什么功能我们就去element找，找到就把对应功能的代码粘贴就完了，不过粘贴也有方法，会在后面详细说明。</h4><h2 id="现在开始从0使用vue-admin-template搭建自己的系统"><a href="#现在开始从0使用vue-admin-template搭建自己的系统" class="headerlink" title="现在开始从0使用vue-admin-template搭建自己的系统"></a>现在开始从0使用vue-admin-template搭建自己的系统</h2><h3 id="前置条件准备"><a href="#前置条件准备" class="headerlink" title="前置条件准备"></a>前置条件准备</h3><h4 id="1、首先从gitee或者GitHub上克隆vue-admin-template的源码，这里我只挂了gitee的路径"><a href="#1、首先从gitee或者GitHub上克隆vue-admin-template的源码，这里我只挂了gitee的路径" class="headerlink" title="1、首先从gitee或者GitHub上克隆vue-admin-template的源码，这里我只挂了gitee的路径"></a>1、首先从gitee或者GitHub上克隆vue-admin-template的源码，这里我只挂了gitee的路径</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitee：https://gitee.com/panjiachen/vue-admin-template</span><br></pre></td></tr></table></figure>

<h4 id="2、你的开发环境中必须具备：Node，NPM，vue。还要有一个编辑前端代码的ide，我使用vscode，你可以使用idea或者其他。没有就去安装，很简单的"><a href="#2、你的开发环境中必须具备：Node，NPM，vue。还要有一个编辑前端代码的ide，我使用vscode，你可以使用idea或者其他。没有就去安装，很简单的" class="headerlink" title="2、你的开发环境中必须具备：Node，NPM，vue。还要有一个编辑前端代码的ide，我使用vscode，你可以使用idea或者其他。没有就去安装，很简单的"></a>2、你的开发环境中必须具备：Node，NPM，vue。还要有一个编辑前端代码的ide，我使用vscode，你可以使用idea或者其他。没有就去安装，很简单的</h4><h4 id="3、来到你获取的源码的文件夹中，在这里打开控制台，然后输入-code-这样就是用vscode打开了这个文件夹"><a href="#3、来到你获取的源码的文件夹中，在这里打开控制台，然后输入-code-这样就是用vscode打开了这个文件夹" class="headerlink" title="3、来到你获取的源码的文件夹中，在这里打开控制台，然后输入 code . 这样就是用vscode打开了这个文件夹"></a>3、来到你获取的源码的文件夹中，在这里打开控制台，然后输入 code . 这样就是用vscode打开了这个文件夹</h4><h4 id="4、在vscode的控制中输入npm-i-下载项目运行需要的依赖。如果依赖下载失败，可能是因为网络原因，可以使用npm的指令更换镜像源，然后使用npm-i-下载依赖，或者直接在npm-i-的后面添加镜像源的地址，这样也可以下载。具体实现可以自己查询。"><a href="#4、在vscode的控制中输入npm-i-下载项目运行需要的依赖。如果依赖下载失败，可能是因为网络原因，可以使用npm的指令更换镜像源，然后使用npm-i-下载依赖，或者直接在npm-i-的后面添加镜像源的地址，这样也可以下载。具体实现可以自己查询。" class="headerlink" title="4、在vscode的控制中输入npm i 下载项目运行需要的依赖。如果依赖下载失败，可能是因为网络原因，可以使用npm的指令更换镜像源，然后使用npm i 下载依赖，或者直接在npm i 的后面添加镜像源的地址，这样也可以下载。具体实现可以自己查询。"></a>4、在vscode的控制中输入npm i 下载项目运行需要的依赖。如果依赖下载失败，可能是因为网络原因，可以使用npm的指令更换镜像源，然后使用npm i 下载依赖，或者直接在npm i 的后面添加镜像源的地址，这样也可以下载。具体实现可以自己查询。</h4><h4 id="5、依赖下载完毕以后，使用指令npm-run-dev-运行项目后，就会弹出系统页面咯"><a href="#5、依赖下载完毕以后，使用指令npm-run-dev-运行项目后，就会弹出系统页面咯" class="headerlink" title="5、依赖下载完毕以后，使用指令npm run dev 运行项目后，就会弹出系统页面咯"></a>5、依赖下载完毕以后，使用指令npm run dev 运行项目后，就会弹出系统页面咯</h4><h3 id="一、修改侧边栏的展示"><a href="#一、修改侧边栏的展示" class="headerlink" title="一、修改侧边栏的展示"></a>一、修改侧边栏的展示</h3><h4 id="1、修改文本"><a href="#1、修改文本" class="headerlink" title="1、修改文本"></a>1、修改文本</h4><p>在路径：src&#x2F;router 也就是路由js中，修改meta属性中的title，这个就是侧边栏中的文本</p>
<p><img src="C:\Users\HRC\AppData\Roaming\Typora\typora-user-images\image-20241115221755134.png" alt="image-20241115221755134"></p>
<p><img src="C:\Users\HRC\AppData\Roaming\Typora\typora-user-images\image-20241115221807379.png" alt="image-20241115221807379"></p>
<h4 id="2、修改文本旁边的图标"><a href="#2、修改文本旁边的图标" class="headerlink" title="2、修改文本旁边的图标"></a>2、修改文本旁边的图标</h4><p>同样路径同样属性下，修改icon，icon就是对应的图标，这个图标可以去elemen官网找到你喜欢的图标的名字，然后粘贴到icon中，就展示成功了：</p>
<p><img src="C:\Users\HRC\AppData\Roaming\Typora\typora-user-images\image-20241115221807379.png" alt="image-20241115221807379"></p>
<p>修改后效果<br>                <img src="C:\Users\HRC\AppData\Roaming\Typora\typora-user-images\image-20241115222028810.png" alt="image-20241115222028810"></p>
<h4 id="3、修改面包屑根导航的名字"><a href="#3、修改面包屑根导航的名字" class="headerlink" title="3、修改面包屑根导航的名字"></a>3、修改面包屑根导航的名字</h4><p>找到src&#x2F;components&#x2F;Breadcrumb，修改里面的title为首页：</p>
<p><img src="C:\Users\HRC\AppData\Roaming\Typora\typora-user-images\image-20241115222229083.png" alt="image-20241115222229083"></p>
<p><img src="C:\Users\HRC\AppData\Roaming\Typora\typora-user-images\image-20241115222243154.png" alt="image-20241115222243154"></p>
<p>修改后效果</p>
<p><img src="C:\Users\HRC\AppData\Roaming\Typora\typora-user-images\image-20241115222308777.png" alt="image-20241115222308777"></p>
<h4 id="4、修改网页的名称"><a href="#4、修改网页的名称" class="headerlink" title="4、修改网页的名称"></a>4、修改网页的名称</h4><p>如图，找到src&#x2F;setting,js，修改title：</p>
<p><img src="C:\Users\HRC\AppData\Roaming\Typora\typora-user-images\image-20241115222412046.png" alt="image-20241115222412046"></p>
<p>修改后效果</p>
<p><img src="C:\Users\HRC\AppData\Roaming\Typora\typora-user-images\image-20241115222506180.png" alt="image-20241115222506180"> </p>
<h3 id="二、标签导航设置"><a href="#二、标签导航设置" class="headerlink" title="二、标签导航设置"></a>二、标签导航设置</h3><h5 id="说明：这是一个功能，无法通过简单的设置就完成，需要具体的代码实现，但是我们不会，可是element上面有这个功能，所以我们直接从element上粘贴对应的功能到我们的模板这里，这样就实现咯"><a href="#说明：这是一个功能，无法通过简单的设置就完成，需要具体的代码实现，但是我们不会，可是element上面有这个功能，所以我们直接从element上粘贴对应的功能到我们的模板这里，这样就实现咯" class="headerlink" title="说明：这是一个功能，无法通过简单的设置就完成，需要具体的代码实现，但是我们不会，可是element上面有这个功能，所以我们直接从element上粘贴对应的功能到我们的模板这里，这样就实现咯"></a>说明：这是一个功能，无法通过简单的设置就完成，需要具体的代码实现，但是我们不会，可是element上面有这个功能，所以我们直接从element上粘贴对应的功能到我们的模板这里，这样就实现咯</h5><h5 id="1、找到-layout-components-AppMain-vue，原本只有，使用keep-alive标签将其包裹如下："><a href="#1、找到-layout-components-AppMain-vue，原本只有，使用keep-alive标签将其包裹如下：" class="headerlink" title="1、找到@&#x2F;layout&#x2F;components&#x2F;AppMain.vue，原本只有，使用keep-alive标签将其包裹如下："></a>1、找到@&#x2F;layout&#x2F;components&#x2F;AppMain.vue，原本只有<router-view :key="key" />，使用keep-alive标签将其包裹如下：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;cachedViews&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、然后你还要在js的computed中添加方法，这个方法就是前面标签中cachedViews的引用啦"><a href="#2、然后你还要在js的computed中添加方法，这个方法就是前面标签中cachedViews的引用啦" class="headerlink" title="2、然后你还要在js的computed中添加方法，这个方法就是前面标签中cachedViews的引用啦"></a>2、然后你还要在js的computed中添加方法，这个方法就是前面标签中cachedViews的引用啦</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cachedViews() &#123;</span><br><span class="line">      return this.$store.state.tagsView.cachedViews</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h5 id="3、模板中的配置做好了，我们需要获取标签导航的组件了，需要在element中复制一整个文件夹。一共三个文件夹：-layout-components-TagView-store-modules-tagsView-js-store-modules-permission-js-把这些element文件夹复制到admin中对应位置"><a href="#3、模板中的配置做好了，我们需要获取标签导航的组件了，需要在element中复制一整个文件夹。一共三个文件夹：-layout-components-TagView-store-modules-tagsView-js-store-modules-permission-js-把这些element文件夹复制到admin中对应位置" class="headerlink" title="3、模板中的配置做好了，我们需要获取标签导航的组件了，需要在element中复制一整个文件夹。一共三个文件夹：@&#x2F;layout&#x2F;components&#x2F;TagView     @store&#x2F;modules&#x2F;tagsView.js     @store&#x2F;modules&#x2F;permission.js  把这些element文件夹复制到admin中对应位置"></a>3、模板中的配置做好了，我们需要获取标签导航的组件了，需要在element中复制一整个文件夹。一共三个文件夹：@&#x2F;layout&#x2F;components&#x2F;TagView     @store&#x2F;modules&#x2F;tagsView.js     @store&#x2F;modules&#x2F;permission.js  把这些element文件夹复制到admin中对应位置</h5><h5 id="4、复制代码。文件复制完毕后需要复制一些代码引用这些文件"><a href="#4、复制代码。文件复制完毕后需要复制一些代码引用这些文件" class="headerlink" title="4、复制代码。文件复制完毕后需要复制一些代码引用这些文件"></a>4、复制代码。文件复制完毕后需要复制一些代码引用这些文件</h5><p>在element中的@store&#x2F;modules&#x2F;getters.js中找到下面这三行代码，复制到admin中对应位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">visitedViews: state =&gt; state.tagsView.visitedViews,</span><br><span class="line">  cachedViews: state =&gt; state.tagsView.cachedViews,</span><br><span class="line">    permission_routes: state =&gt; state.permission.routes,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5、添加代码。完成上面步骤以后，需要再添加一些代码把我们添加的组件导入"><a href="#5、添加代码。完成上面步骤以后，需要再添加一些代码把我们添加的组件导入" class="headerlink" title="5、添加代码。完成上面步骤以后，需要再添加一些代码把我们添加的组件导入"></a>5、添加代码。完成上面步骤以后，需要再添加一些代码把我们添加的组件导入</h5><p>在@store&#x2F;modules&#x2F;getters.js添加代码导入你刚才1添加的两个js。permission和TagView 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import permission from &#x27;./modules/permission&#x27;</span><br><span class="line">import tagsView from &#x27;./modules/tagsView&#x27;</span><br></pre></td></tr></table></figure>

<p>然后在modules中添加代码引用导入的组件permission，tagsView</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">    app,</span><br><span class="line">    settings,</span><br><span class="line">    user,</span><br><span class="line">    permission,</span><br><span class="line">    tagsView</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h5 id="6、然后在-layout-index-vue对应位置调用组件，也就是渲染了，如图："><a href="#6、然后在-layout-index-vue对应位置调用组件，也就是渲染了，如图：" class="headerlink" title="6、然后在@layout&#x2F;index.vue对应位置调用组件，也就是渲染了，如图："></a>6、然后在@layout&#x2F;index.vue对应位置调用组件，也就是渲染了，如图：</h5><p><img src="D:\MyData\Documents\学习笔记\计算机技术\image-20241117191151927.png" alt="image-20241117191151927"></p>
<h5 id="7、最后，在-layout-components-index-js中添加代码"><a href="#7、最后，在-layout-components-index-js中添加代码" class="headerlink" title="7、最后，在@&#x2F;layout&#x2F;components&#x2F;index.js中添加代码"></a>7、最后，在@&#x2F;layout&#x2F;components&#x2F;index.js中添加代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123; default as TagsView &#125; from &#x27;./TagsView&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="8、修改bug。"><a href="#8、修改bug。" class="headerlink" title="8、修改bug。"></a>8、修改bug。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、bug：</span><br><span class="line">这样添加的标签导航，会存在把首页叉掉后找不到i页面的情况，不信你试试。解决办法就是在路由的首页的meta部分添加一个affix：true，这是添加固钉，这样首页就不可以删除了。</span><br><span class="line">2、解决一个警告：&quot;export &#x27;asyncRoutes&#x27; was not found in &#x27;@/router&#x27;，在路由中添加下列代码</span><br><span class="line">/**</span><br><span class="line"> * 动态路由</span><br><span class="line"> */</span><br><span class="line">export const asyncRoutes=[]</span><br></pre></td></tr></table></figure>

<h5 id="这样添加的标签导航，会存在把首页叉掉后找不到i页面的情况，不信你试试。解决办法就是在路由的首页的meta部分添加一个affix：true，这是添加固钉，这样首页就不可以删除了。"><a href="#这样添加的标签导航，会存在把首页叉掉后找不到i页面的情况，不信你试试。解决办法就是在路由的首页的meta部分添加一个affix：true，这是添加固钉，这样首页就不可以删除了。" class="headerlink" title="这样添加的标签导航，会存在把首页叉掉后找不到i页面的情况，不信你试试。解决办法就是在路由的首页的meta部分添加一个affix：true，这是添加固钉，这样首页就不可以删除了。"></a>这样添加的标签导航，会存在把首页叉掉后找不到i页面的情况，不信你试试。解决办法就是在路由的首页的meta部分添加一个affix：true，这是添加固钉，这样首页就不可以删除了。</h5><h5 id="这样就顺利添加一个标签导航功能"><a href="#这样就顺利添加一个标签导航功能" class="headerlink" title="这样就顺利添加一个标签导航功能"></a>这样就顺利添加一个标签导航功能</h5><h4 id="三、修改登陆页面样式"><a href="#三、修改登陆页面样式" class="headerlink" title="三、修改登陆页面样式"></a>三、修改登陆页面样式</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/vue3+springboot%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/vue3+springboot%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">前后端分离项目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:20:59" itemprop="dateModified" datetime="2024-11-20T21:20:59+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="记录我刚开始前后端分离开发时候遇到的问题"><a href="#记录我刚开始前后端分离开发时候遇到的问题" class="headerlink" title="记录我刚开始前后端分离开发时候遇到的问题"></a>记录我刚开始前后端分离开发时候遇到的问题</h1><h2 id="一、前端"><a href="#一、前端" class="headerlink" title="一、前端"></a>一、前端</h2><h4 id="前端部分刚开始接触，所以遇到很多问题，接下来我一一列举"><a href="#前端部分刚开始接触，所以遇到很多问题，接下来我一一列举" class="headerlink" title="前端部分刚开始接触，所以遇到很多问题，接下来我一一列举"></a>前端部分刚开始接触，所以遇到很多问题，接下来我一一列举</h4><h5 id="1、使用ts来代替js没什么大问题，但是ts默认无法识别vue后缀的组件，所以需要手动到env-d-ts文件里面配置，不然你在import组件的时候会飘红，虽然不影响运行，但是不好看"><a href="#1、使用ts来代替js没什么大问题，但是ts默认无法识别vue后缀的组件，所以需要手动到env-d-ts文件里面配置，不然你在import组件的时候会飘红，虽然不影响运行，但是不好看" class="headerlink" title="1、使用ts来代替js没什么大问题，但是ts默认无法识别vue后缀的组件，所以需要手动到env.d.ts文件里面配置，不然你在import组件的时候会飘红，虽然不影响运行，但是不好看"></a>1、使用ts来代替js没什么大问题，但是ts默认无法识别vue后缀的组件，所以需要手动到env.d.ts文件里面配置，不然你在import组件的时候会飘红，虽然不影响运行，但是不好看</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare module &#x27;*vue&#x27; &#123;</span><br><span class="line">    import &#123; ComponentOptions &#125; from &quot;vue&quot;;</span><br><span class="line">    const ComponentOptions: ComponentOptions</span><br><span class="line">    export default ComponentOptions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、如果使用vscode来编写前端代码，在使用export-default导出时，要注意单词之间要加空格，同时default和后面的大括号之间也要加空格，不然格式检查会飘红，不影响运行，但恶心"><a href="#2、如果使用vscode来编写前端代码，在使用export-default导出时，要注意单词之间要加空格，同时default和后面的大括号之间也要加空格，不然格式检查会飘红，不影响运行，但恶心" class="headerlink" title="2、如果使用vscode来编写前端代码，在使用export default导出时，要注意单词之间要加空格，同时default和后面的大括号之间也要加空格，不然格式检查会飘红，不影响运行，但恶心"></a>2、如果使用vscode来编写前端代码，在使用export default导出时，要注意单词之间要加空格，同时default和后面的大括号之间也要加空格，不然格式检查会飘红，不影响运行，但恶心</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正确：&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&quot;Login&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">错误：&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default&#123;  &lt;--区别在这</span><br><span class="line">    name:&quot;Login&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3、我们使用axios和后端进行异步请求的时候，一定要处理跨域请求的问题，直接在后端controller那上面加一个-CrossOrigin注解就可以了，不然前后端请求会被浏览器拦截，导致请求失败"><a href="#3、我们使用axios和后端进行异步请求的时候，一定要处理跨域请求的问题，直接在后端controller那上面加一个-CrossOrigin注解就可以了，不然前后端请求会被浏览器拦截，导致请求失败" class="headerlink" title="3、我们使用axios和后端进行异步请求的时候，一定要处理跨域请求的问题，直接在后端controller那上面加一个@CrossOrigin注解就可以了，不然前后端请求会被浏览器拦截，导致请求失败"></a>3、我们使用axios和后端进行异步请求的时候，一定要处理跨域请求的问题，直接在后端controller那上面加一个@CrossOrigin注解就可以了，不然前后端请求会被浏览器拦截，导致请求失败</h5><h5 id="4、我在编写登录页面异步请求编程式路由跳转的时候，点击登录，后端显示请求成功，当前页面自动刷新了，但是没有跳转到我想要的页面，无论请求多少次都在刷新，但是没有实现跳转，我找了很久很久，终于发现了原因，由于我登录界面使用的式form表单来接收数据，在提交数据的时候，form表单会自动刷新，这就导致我当前页面刷新了，但是没有跳转。解决办法就是在form表单上使用-submit-prevent绑定一个函数（名字随你），在这个函数里面传入exent参数，然后编写代码event-preventDefault-，这样就阻止了表单提交自动刷新了"><a href="#4、我在编写登录页面异步请求编程式路由跳转的时候，点击登录，后端显示请求成功，当前页面自动刷新了，但是没有跳转到我想要的页面，无论请求多少次都在刷新，但是没有实现跳转，我找了很久很久，终于发现了原因，由于我登录界面使用的式form表单来接收数据，在提交数据的时候，form表单会自动刷新，这就导致我当前页面刷新了，但是没有跳转。解决办法就是在form表单上使用-submit-prevent绑定一个函数（名字随你），在这个函数里面传入exent参数，然后编写代码event-preventDefault-，这样就阻止了表单提交自动刷新了" class="headerlink" title="4、我在编写登录页面异步请求编程式路由跳转的时候，点击登录，后端显示请求成功，当前页面自动刷新了，但是没有跳转到我想要的页面，无论请求多少次都在刷新，但是没有实现跳转，我找了很久很久，终于发现了原因，由于我登录界面使用的式form表单来接收数据，在提交数据的时候，form表单会自动刷新，这就导致我当前页面刷新了，但是没有跳转。解决办法就是在form表单上使用@submit.prevent绑定一个函数（名字随你），在这个函数里面传入exent参数，然后编写代码event.preventDefault();，这样就阻止了表单提交自动刷新了"></a>4、我在编写登录页面异步请求编程式路由跳转的时候，点击登录，后端显示请求成功，当前页面自动刷新了，但是没有跳转到我想要的页面，无论请求多少次都在刷新，但是没有实现跳转，我找了很久很久，终于发现了原因，由于我登录界面使用的式form表单来接收数据，在提交数据的时候，form表单会自动刷新，这就导致我当前页面刷新了，但是没有跳转。解决办法就是在form表单上使用@submit.prevent绑定一个函数（名字随你），在这个函数里面传入exent参数，然后编写代码event.preventDefault();，这样就阻止了表单提交自动刷新了</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">模板部分：</span><br><span class="line">&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line">.....</span><br><span class="line">脚本部分：</span><br><span class="line">function onSubmit(event:any)&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、在配置嵌套路由的时候，一定要记得子路由的路径不加-。如果是重定向记得写全路径"><a href="#5、在配置嵌套路由的时候，一定要记得子路由的路径不加-。如果是重定向记得写全路径" class="headerlink" title="5、在配置嵌套路由的时候，一定要记得子路由的路径不加  &#x2F;   。如果是重定向记得写全路径"></a>5、在配置嵌套路由的时候，一定要记得子路由的路径不加  &#x2F;   。如果是重定向记得写全路径</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      path:&#x27;/index&#x27;,</span><br><span class="line">      name:&#x27;index&#x27;,</span><br><span class="line">      component:()=&gt;import(&#x27;../views/index/index.vue&#x27;),</span><br><span class="line">      children:[</span><br><span class="line">        &#123;</span><br><span class="line">          path:&#x27;recent&#x27;,  《---子路由路径</span><br><span class="line">          name:&#x27;recent&#x27;,</span><br><span class="line">          component:()=&gt;import(&#x27;../views/index/recent/index.vue&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path:&#x27;recommend&#x27;,</span><br><span class="line">          name:&#x27;recommend&#x27;,</span><br><span class="line">          component:()=&gt;import(&#x27;../views/index/recommend/index.vue&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h5 id="6、在使用路由渲染的时候，一定要记得在你要渲染的地方添加-，这样页面才会渲染你路由的组件"><a href="#6、在使用路由渲染的时候，一定要记得在你要渲染的地方添加-，这样页面才会渲染你路由的组件" class="headerlink" title="6、在使用路由渲染的时候，一定要记得在你要渲染的地方添加  ，这样页面才会渲染你路由的组件"></a>6、在使用路由渲染的时候，一定要记得在你要渲染的地方添加 <RouterView></RouterView> ，这样页面才会渲染你路由的组件</h5><h5 id="7、使用pinia进行状态管理，比如存储token，现在store里编写一个ts脚本，state就是它存储的数据，还有getter和seter函数，方便获取和修改这些数据。你可以直接在组件中引入这个ts，然后使用setter和getter修改state"><a href="#7、使用pinia进行状态管理，比如存储token，现在store里编写一个ts脚本，state就是它存储的数据，还有getter和seter函数，方便获取和修改这些数据。你可以直接在组件中引入这个ts，然后使用setter和getter修改state" class="headerlink" title="7、使用pinia进行状态管理，比如存储token，现在store里编写一个ts脚本，state就是它存储的数据，还有getter和seter函数，方便获取和修改这些数据。你可以直接在组件中引入这个ts，然后使用setter和getter修改state"></a>7、使用pinia进行状态管理，比如存储token，现在store里编写一个ts脚本，state就是它存储的数据，还有getter和seter函数，方便获取和修改这些数据。你可以直接在组件中引入这个ts，然后使用setter和getter修改state</h5><h5 id="8、如果想在请求的时候，做一些前置操作，比如添加一个请求头用来存放token，可以直接在src下面编写一个axios的ts文件，在文件中你可以自定义一个axios，在其中添加一个请求拦截器，在这个拦截器中添加存放token的逻辑"><a href="#8、如果想在请求的时候，做一些前置操作，比如添加一个请求头用来存放token，可以直接在src下面编写一个axios的ts文件，在文件中你可以自定义一个axios，在其中添加一个请求拦截器，在这个拦截器中添加存放token的逻辑" class="headerlink" title="8、如果想在请求的时候，做一些前置操作，比如添加一个请求头用来存放token，可以直接在src下面编写一个axios的ts文件，在文件中你可以自定义一个axios，在其中添加一个请求拦截器，在这个拦截器中添加存放token的逻辑"></a>8、如果想在请求的时候，做一些前置操作，比如添加一个请求头用来存放token，可以直接在src下面编写一个axios的ts文件，在文件中你可以自定义一个axios，在其中添加一个请求拦截器，在这个拦截器中添加存放token的逻辑</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// src/axios.ts</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">const instance = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;https:localhost:9090/&#x27;,</span><br><span class="line">  timeout: 1000,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 添加请求拦截器</span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    const token = localStorage.getItem(&#x27;token&#x27;);//使用localStorage.setItem(&#x27;token&#x27;)可以存放token到本地浏览器</span><br><span class="line">    if (token) &#123;</span><br><span class="line">      config.headers[&#x27;Authorization&#x27;] = `Bearer $&#123;token&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">    return config;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default instance;</span><br></pre></td></tr></table></figure>



<h2 id="二、后端"><a href="#二、后端" class="headerlink" title="二、后端"></a>二、后端</h2><h5 id="1、注意请求格式要和controller的注解一一对应"><a href="#1、注意请求格式要和controller的注解一一对应" class="headerlink" title="1、注意请求格式要和controller的注解一一对应"></a>1、注意请求格式要和controller的注解一一对应</h5>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" class="post-title-link" itemprop="url">蓝桥杯java组比赛记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:23:02" itemprop="dateModified" datetime="2024-11-20T21:23:02+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="蓝桥杯算法竞赛"><a href="#蓝桥杯算法竞赛" class="headerlink" title="蓝桥杯算法竞赛"></a>蓝桥杯算法竞赛</h1><h5 id="更新时间：2024年9月11日"><a href="#更新时间：2024年9月11日" class="headerlink" title="更新时间：2024年9月11日"></a>更新时间：2024年9月11日</h5><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><h4 id="1、提交的代码不要带pakage，不然会编译出错"><a href="#1、提交的代码不要带pakage，不然会编译出错" class="headerlink" title="1、提交的代码不要带pakage，不然会编译出错"></a>1、提交的代码不要带pakage，不然会编译出错</h4><h4 id="2、提交的类名必须是Main，不然会编译报错"><a href="#2、提交的类名必须是Main，不然会编译报错" class="headerlink" title="2、提交的类名必须是Main，不然会编译报错"></a>2、提交的类名必须是Main，不然会编译报错</h4><h4 id="3、导包：import-java-util"><a href="#3、导包：import-java-util" class="headerlink" title="3、导包：import java.util.*;"></a>3、导包：import java.util.*;</h4><h2 id="eclipse使用技巧-快捷键"><a href="#eclipse使用技巧-快捷键" class="headerlink" title="eclipse使用技巧&#x2F;快捷键"></a>eclipse使用技巧&#x2F;快捷键</h2><h4 id="1、alt-自动联想"><a href="#1、alt-自动联想" class="headerlink" title="1、alt+&#x2F; 自动联想"></a>1、alt+&#x2F; 自动联想</h4><h4 id="2、ctrl-alt-下箭头-复制本行到下一行"><a href="#2、ctrl-alt-下箭头-复制本行到下一行" class="headerlink" title="2、ctrl + alt +下箭头 复制本行到下一行"></a>2、ctrl + alt +下箭头 复制本行到下一行</h4><h4 id="3、ctrl-shift-o-自动导包"><a href="#3、ctrl-shift-o-自动导包" class="headerlink" title="3、ctrl+shift+o 自动导包"></a>3、ctrl+shift+o 自动导包</h4><h3 id="编程技巧："><a href="#编程技巧：" class="headerlink" title="编程技巧："></a>编程技巧：</h3><h4 id="1、对于字母大小写转换，只需要将字符对32进行异或操作就可以了"><a href="#1、对于字母大小写转换，只需要将字符对32进行异或操作就可以了" class="headerlink" title="1、对于字母大小写转换，只需要将字符对32进行异或操作就可以了"></a>1、对于字母大小写转换，只需要将字符对32进行异或操作就可以了</h4><h4 id="2、对于确定一个除法算式的结果是整数还是小数可以使用原数减去原数取整然后和0比较的方法，非常简单且快捷"><a href="#2、对于确定一个除法算式的结果是整数还是小数可以使用原数减去原数取整然后和0比较的方法，非常简单且快捷" class="headerlink" title="2、对于确定一个除法算式的结果是整数还是小数可以使用原数减去原数取整然后和0比较的方法，非常简单且快捷"></a>2、对于确定一个除法算式的结果是整数还是小数可以使用原数减去原数取整然后和0比较的方法，非常简单且快捷</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码示例：</span><br><span class="line">float a=123.456,val=0.0;</span><br><span class="line">int b=0;</span><br><span class="line">b=(int)a;</span><br><span class="line">val =a-b;</span><br></pre></td></tr></table></figure>

<h4 id="3、你记住，但凡是碰到什么动态规划，递推，递归这种，一定要记得-开long-！一不小心就会溢出"><a href="#3、你记住，但凡是碰到什么动态规划，递推，递归这种，一定要记得-开long-！一不小心就会溢出" class="headerlink" title="3、你记住，但凡是碰到什么动态规划，递推，递归这种，一定要记得 开long ！一不小心就会溢出"></a>3、你记住，但凡是碰到什么动态规划，递推，递归这种，一定要记得 开long ！一不小心就会溢出</h4><h4 id="4、对于浮点数的运算处理，一般将输入的浮点数转换成整数来运算，浮点数运算精准，会导致结果错误，比如颠倒一个浮点数的顺序，就可以直接将输入的浮点数直接转换成整数，然后通过取余运算颠倒顺序，然后再恢复成小数就可以了"><a href="#4、对于浮点数的运算处理，一般将输入的浮点数转换成整数来运算，浮点数运算精准，会导致结果错误，比如颠倒一个浮点数的顺序，就可以直接将输入的浮点数直接转换成整数，然后通过取余运算颠倒顺序，然后再恢复成小数就可以了" class="headerlink" title="4、对于浮点数的运算处理，一般将输入的浮点数转换成整数来运算，浮点数运算精准，会导致结果错误，比如颠倒一个浮点数的顺序，就可以直接将输入的浮点数直接转换成整数，然后通过取余运算颠倒顺序，然后再恢复成小数就可以了"></a>4、对于浮点数的运算处理，一般将输入的浮点数转换成整数来运算，浮点数运算精准，会导致结果错误，比如颠倒一个浮点数的顺序，就可以直接将输入的浮点数直接转换成整数，然后通过取余运算颠倒顺序，然后再恢复成小数就可以了</h4><h4 id="5、对于一组if-else和一组if-if-判断语句的区别和可能出现的潜在问题，例如："><a href="#5、对于一组if-else和一组if-if-判断语句的区别和可能出现的潜在问题，例如：" class="headerlink" title="5、对于一组if-else和一组if-if 判断语句的区别和可能出现的潜在问题，例如："></a>5、对于一组if-else和一组if-if 判断语句的区别和可能出现的潜在问题，例如：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">代码：</span><br><span class="line">if(x==7||(r+x)==7)</span><br><span class="line">	r-=1;</span><br><span class="line">else if((x+r)&gt;7)</span><br><span class="line">	r-=2;</span><br><span class="line">和代码：</span><br><span class="line">if(x==7||(r+x)==7)</span><br><span class="line">	r-=1;</span><br><span class="line">if((x+r)&gt;7)</span><br><span class="line">	r-=2;</span><br><span class="line">1、执行顺序：在第二段代码中，无论第一个 if 条件是否为真，第二个 if 条件都会被执行。这可能导致在某些情况下 r 被减去的值比预期的多。例如，如果 x 等于 7，那么 r 首先会减去 1，然后如果 (x+r) 的和大于 7，r 还会再减去 2，即使这个额外的减少可能不是预期的行为。</span><br><span class="line"></span><br><span class="line">2、逻辑控制：第一段代码通过使用 else if 提供了更好的逻辑控制，确保只有在第一个条件不满足的情况下，才会检查第二个条件。这有助于避免不必要的计算和潜在的错误。</span><br></pre></td></tr></table></figure>

<p><strong>第二段代码的主要问题是它缺乏逻辑控制，可能会导致 <code>r</code> 被不必要地多次减少，特别是在第一个条件已经满足的情况下。正确的代码选择取决于你的具体需求和预期的行为。如果你希望在满足第一个条件后不再检查第二个条件，应该使用第一段代码中的 <code>if-else if</code> 结构。如果你希望无论第一个条件是否满足都检查第二个条件，那么第二段代码是合适的，但你需要确保这种逻辑符合你的预期。</strong></p>
<h3 id="Debug注意事项："><a href="#Debug注意事项：" class="headerlink" title="Debug注意事项："></a>Debug注意事项：</h3><h4 id="1、当两个部分的代码是复制粘贴写的，比如代码2逻辑与代码1逻辑差不多时，我直接copy代码1到代码2位置，改一改。但是一定要注意！如果你的代码1有逻辑上的bug，那么你的代码2也极有可能会存在bug，在寻找时一定要注意不能只改代码1，还要检查代码2！遭了好多次了，该长点记性了，哭-，这次把它记下来，方便复习"><a href="#1、当两个部分的代码是复制粘贴写的，比如代码2逻辑与代码1逻辑差不多时，我直接copy代码1到代码2位置，改一改。但是一定要注意！如果你的代码1有逻辑上的bug，那么你的代码2也极有可能会存在bug，在寻找时一定要注意不能只改代码1，还要检查代码2！遭了好多次了，该长点记性了，哭-，这次把它记下来，方便复习" class="headerlink" title="1、当两个部分的代码是复制粘贴写的，比如代码2逻辑与代码1逻辑差不多时，我直接copy代码1到代码2位置，改一改。但是一定要注意！如果你的代码1有逻辑上的bug，那么你的代码2也极有可能会存在bug，在寻找时一定要注意不能只改代码1，还要检查代码2！遭了好多次了，该长点记性了，哭~，这次把它记下来，方便复习"></a>1、当两个部分的代码是复制粘贴写的，比如代码2逻辑与代码1逻辑差不多时，我直接copy代码1到代码2位置，改一改。但是一定要注意！如果你的代码1有逻辑上的bug，那么你的代码2也极有可能会存在bug，在寻找时一定要注意不能只改代码1，还要检查代码2！遭了好多次了，该长点记性了，哭~，这次把它记下来，方便复习</h4><h3 id="比赛习惯："><a href="#比赛习惯：" class="headerlink" title="比赛习惯："></a>比赛习惯：</h3><h4 id="1、比赛时间较长，比赛的时候可以带点吃的和水"><a href="#1、比赛时间较长，比赛的时候可以带点吃的和水" class="headerlink" title="1、比赛时间较长，比赛的时候可以带点吃的和水"></a>1、比赛时间较长，比赛的时候可以带点吃的和水</h4><h4 id="2、答题完毕后，检查一下代码格式以后再离开，免得事后担心自己的格式错误导致0分（Main写成Mian啊带包名之类的）"><a href="#2、答题完毕后，检查一下代码格式以后再离开，免得事后担心自己的格式错误导致0分（Main写成Mian啊带包名之类的）" class="headerlink" title="2、答题完毕后，检查一下代码格式以后再离开，免得事后担心自己的格式错误导致0分（Main写成Mian啊带包名之类的）"></a>2、答题完毕后，检查一下代码格式以后再离开，免得事后担心自己的格式错误导致0分（Main写成Mian啊带包名之类的）</h4><h3 id="一、枚举"><a href="#一、枚举" class="headerlink" title="一、枚举"></a>一、枚举</h3><h3 id="二、前缀和-差分"><a href="#二、前缀和-差分" class="headerlink" title="二、前缀和&#x2F;差分"></a>二、前缀和&#x2F;差分</h3><h3 id="三、尺取法-差分"><a href="#三、尺取法-差分" class="headerlink" title="三、尺取法&#x2F;差分"></a>三、尺取法&#x2F;差分</h3><h3 id="四、贪心"><a href="#四、贪心" class="headerlink" title="四、贪心"></a>四、贪心</h3><h3 id="五、二分"><a href="#五、二分" class="headerlink" title="五、二分"></a>五、二分</h3><h3 id="六、递归-分治"><a href="#六、递归-分治" class="headerlink" title="六、递归&#x2F;分治"></a>六、递归&#x2F;分治</h3><h3 id="七、DFS深度优先搜索"><a href="#七、DFS深度优先搜索" class="headerlink" title="七、DFS深度优先搜索"></a>七、DFS深度优先搜索</h3><h4 id="1、搜索所有路径"><a href="#1、搜索所有路径" class="headerlink" title="1、搜索所有路径"></a>1、搜索所有路径</h4><h4 id="2、一般通过栈显示或者隐式的实现。其实也就是回溯，当递归到条件满足的时候，将当前这个路径保存，然后返回，返回到上一层递归调用后面，然后就执行回溯，将刚才标记的节点恢复为未访问，同时如果这个节点添加到集合里了的话还要将其移除"><a href="#2、一般通过栈显示或者隐式的实现。其实也就是回溯，当递归到条件满足的时候，将当前这个路径保存，然后返回，返回到上一层递归调用后面，然后就执行回溯，将刚才标记的节点恢复为未访问，同时如果这个节点添加到集合里了的话还要将其移除" class="headerlink" title="2、一般通过栈显示或者隐式的实现。其实也就是回溯，当递归到条件满足的时候，将当前这个路径保存，然后返回，返回到上一层递归调用后面，然后就执行回溯，将刚才标记的节点恢复为未访问，同时如果这个节点添加到集合里了的话还要将其移除"></a>2、一般通过栈显示或者隐式的实现。其实也就是回溯，当递归到条件满足的时候，将当前这个路径保存，然后返回，返回到上一层递归调用后面，然后就执行回溯，将刚才标记的节点恢复为未访问，同时如果这个节点添加到集合里了的话还要将其移除</h4><h4 id="3、案例：枚举排列"><a href="#3、案例：枚举排列" class="headerlink" title="3、案例：枚举排列"></a>3、案例：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/B3623">枚举排列</a></h4><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list=new ArrayList();</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner sc=new Scanner(System.in);</span><br><span class="line">		int n=sc.nextInt();</span><br><span class="line">		int k=sc.nextInt();</span><br><span class="line">		int []f=new int [n+1];</span><br><span class="line">		ArrayList&lt;Integer&gt; num=new ArrayList();</span><br><span class="line">		dfs(n,k,f,num);</span><br><span class="line">		</span><br><span class="line">		for(int i=0;i&lt;list.size();i++) &#123;</span><br><span class="line">			for(int j=0;j&lt;k;j++) &#123;</span><br><span class="line">				System.out.print(list.get(i).get(j)+&quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	private static void dfs(int n,int k,int[]f,ArrayList&lt;Integer&gt; num) &#123;</span><br><span class="line">		if(num.size()==k) &#123;</span><br><span class="line">			list.add(new ArrayList(num));</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">			if(f[i]==1)continue;</span><br><span class="line">			f[i]=1;</span><br><span class="line">			num.add(i);</span><br><span class="line">			dfs(n,k,f,num);</span><br><span class="line">			f[i]=0;</span><br><span class="line">			num.remove(num.size()-1);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="八、BFS广度优先搜索"><a href="#八、BFS广度优先搜索" class="headerlink" title="八、BFS广度优先搜索"></a>八、BFS广度优先搜索</h3><h4 id="1、一般用来寻找最短路径。还有其他用途，但我还不会"><a href="#1、一般用来寻找最短路径。还有其他用途，但我还不会" class="headerlink" title="1、一般用来寻找最短路径。还有其他用途，但我还不会"></a>1、一般用来寻找最短路径。还有其他用途，但我还不会</h4><h4 id="2、使用队列来实现-“分裂”，当前节点有其他可以访问的节点，我们就将其他节点都给入队。这样就将一个节点分成若干个可访问的节点，那么一直分到最后，就一定是最短的那个路径先满足条件"><a href="#2、使用队列来实现-“分裂”，当前节点有其他可以访问的节点，我们就将其他节点都给入队。这样就将一个节点分成若干个可访问的节点，那么一直分到最后，就一定是最短的那个路径先满足条件" class="headerlink" title="2、使用队列来实现 “分裂”，当前节点有其他可以访问的节点，我们就将其他节点都给入队。这样就将一个节点分成若干个可访问的节点，那么一直分到最后，就一定是最短的那个路径先满足条件"></a>2、使用队列来实现 “分裂”，当前节点有其他可以访问的节点，我们就将其他节点都给入队。这样就将一个节点分成若干个可访问的节点，那么一直分到最后，就一定是最短的那个路径先满足条件</h4><h4 id="3、案例：离开中山路"><a href="#3、案例：离开中山路" class="headerlink" title="3、案例：离开中山路"></a>3、案例：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1746">离开中山路</a></h4><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner sc=new Scanner(System.in);</span><br><span class="line">		int n=sc.nextInt();</span><br><span class="line">		int [][]map=new int [n+1][n+1];</span><br><span class="line">		for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">			String s=sc.next();</span><br><span class="line">			for(int j=1;j&lt;=n;j++) &#123;</span><br><span class="line">				map[i][j]=s.charAt(j-1)-&#x27;0&#x27;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int []x=new int [3];</span><br><span class="line">		int []y=new int [3];</span><br><span class="line">		for(int i=1;i&lt;=2;i++) &#123;</span><br><span class="line">			x[i]=sc.nextInt();</span><br><span class="line">			y[i]=sc.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		bfs(n,x,y,map);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public static void bfs(int n,int []x,int []y,int[][]map) &#123;</span><br><span class="line">		LinkedList&lt;Node&gt; queue=new LinkedList();</span><br><span class="line">		int []dx=new int[] &#123;1,0,-1,0&#125;;//x方向数组</span><br><span class="line">		int []dy=new int[] &#123;0,1,0,-1&#125;;//y方向数组</span><br><span class="line">		//初始化入队</span><br><span class="line">		Node node=new Node(x[1],y[1],0);//起点默认可通过</span><br><span class="line">		queue.add(node);</span><br><span class="line">		map[x[1]][y[1]]=1;</span><br><span class="line">		while(!queue.isEmpty()) &#123;</span><br><span class="line">			Node no=queue.poll();</span><br><span class="line">			for(int i=0;i&lt;4;i++) &#123;</span><br><span class="line">				int _x=no.x+dx[i];</span><br><span class="line">				int _y=no.y+dy[i];</span><br><span class="line">				if(_x&lt;=0||_y&lt;=0||_x&gt;n||_y&gt;n||map[_x][_y]==1)continue;</span><br><span class="line">				if(map[_x][_y]==0) &#123;</span><br><span class="line">					map[_x][_y]=1;</span><br><span class="line">					queue.add(new Node(_x,_y,no.step+1));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(no.x==x[2]&amp;&amp;no.y==y[2])System.out.println(no.step);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Node&#123;</span><br><span class="line">	int step;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">	Node()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	Node(int x,int y,int step)&#123;</span><br><span class="line">		this.x=x;</span><br><span class="line">		this.y=y;</span><br><span class="line">		this.step=step;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="九、DP动态规划"><a href="#九、DP动态规划" class="headerlink" title="九、DP动态规划"></a>九、DP动态规划</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SoulSend</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
