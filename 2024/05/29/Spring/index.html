<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="SSM框架尚硅谷的SSMu框架的课件：快速掌握：全新SSM+Spring Boot+MyBatis-Plus实战精讲 (wolai.com) 源码的远程仓库：SoulSend&#x2F;Spring: 学习SpringIoc容器和id的代码仓库 (github.com) Spring framework介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）控制">
<meta property="og:type" content="article">
<meta property="og:title" content="spring">
<meta property="og:url" content="http://example.com/2024/05/29/Spring/index.html">
<meta property="og:site_name" content="Zard博客">
<meta property="og:description" content="SSM框架尚硅谷的SSMu框架的课件：快速掌握：全新SSM+Spring Boot+MyBatis-Plus实战精讲 (wolai.com) 源码的远程仓库：SoulSend&#x2F;Spring: 学习SpringIoc容器和id的代码仓库 (github.com) Spring framework介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）控制">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-28T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-20T13:19:02.919Z">
<meta property="article:author" content="SoulSend">
<meta property="article:tag" content="JavaWeb">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2024/05/29/Spring/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/05/29/Spring/","path":"2024/05/29/Spring/","title":"spring"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>spring | Zard博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zard博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SSM%E6%A1%86%E6%9E%B6"><span class="nav-number">1.</span> <span class="nav-text">SSM框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-framework"><span class="nav-number">1.1.</span> <span class="nav-text">Spring framework</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A%E8%BF%99%E4%B8%AA%E6%A1%86%E6%9E%B6%E6%98%AF%E6%95%B4%E4%B8%AAspring%E7%94%9F%E6%80%81%E7%9A%84%E5%9F%BA%E5%BA%A7%EF%BC%8C%E5%B0%B1%E5%B9%B2%E4%B8%A4%E4%BB%B6%E4%BA%8B%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IOC%EF%BC%89%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8XML%E9%85%8D%E7%BD%AEIOC%E5%AE%B9%E5%99%A8%E7%9A%84ioc-di"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">使用XML配置IOC容器的ioc&#x2F;di</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">1.1.0.2.1.</span> <span class="nav-text">使用步骤：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEioc%E5%AE%B9%E5%99%A8"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">使用注解配置ioc容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ioc%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">ioc配置使用步骤：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%A0%E5%8F%AF%E5%9C%A8%E6%B3%A8%E8%A7%A3%E5%90%8E%E9%9D%A2%E6%8C%87%E5%AE%9Avalue%E5%B1%9E%E6%80%A7%E6%9D%A5%E8%AE%BE%E7%BD%AEbean%E7%9A%84%E7%B1%BB%E5%90%8D"><span class="nav-number">1.1.0.4.1.</span> <span class="nav-text">你可在注解后面指定value属性来设置bean的类名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8DI%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.0.4.2.</span> <span class="nav-text">引用DI配置步骤:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.1.0.4.3.</span> <span class="nav-text">注解流程：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95JSR-250%E6%B3%A8%E8%A7%A3-Resource%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%B3%A8%E8%A7%A3%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8E%EF%BC%9A-Autowired-Qualifier"><span class="nav-number">1.1.0.4.4.</span> <span class="nav-text">扩展JSR-250注解@Resource，这个注解就相当于：@Autowired + @Qualifier</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8BDI%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="nav-number">1.1.0.4.5.</span> <span class="nav-text">基本类型DI配置：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB%EF%BC%88%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%EF%BC%89"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">配置类（完全注解开发）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E6%9D%A5%E4%BB%A3%E6%9B%BFXMl%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E7%94%A8%E6%B3%A8%E8%A7%A3-Configuration%E6%9D%A5%E6%A0%87%E6%B3%A8%E3%80%82%E5%9C%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E9%87%8C%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9D%A5%E9%85%8D%E7%BD%AEioc%E5%92%8Cdi%E8%BF%99%E6%A0%B7%E5%B0%B1%E8%84%B1%E7%A6%BB%E4%BA%86xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BE%BE%E6%88%90%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">1.1.0.5.1.</span> <span class="nav-text">使用配置类来代替XMl配置文件，用注解@Configuration来标注。在配置类里使用注解来配置ioc和di这样就脱离了xml配置文件，达成完全注解开发的目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.0.5.2.</span> <span class="nav-text">@Import注解的使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">AOP面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%B1%BB%E4%BC%BC%E6%88%BF%E5%AE%A2%E2%80%94%E2%80%93%E4%B8%AD%E4%BB%8B%E2%80%94%E2%80%93%E6%88%BF%E4%B8%9C%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E6%8F%90%E5%8F%96%E5%87%BA%E6%9D%A5%EF%BC%8C%E9%9D%9E%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%88%E6%97%A5%E5%BF%97%E4%B9%8B%E7%B1%BB%E7%9A%84%EF%BC%89%E6%94%BE%E5%88%B0%E4%BB%A3%E7%90%86%E7%B1%BB%E9%87%8C%E3%80%82%E8%BF%99%E6%A0%B7%E5%81%9A%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="nav-number">1.1.0.6.1.</span> <span class="nav-text">代理模式：类似房客—–中介—–房东的关系，我们把一个方法的核心逻辑提取出来，非核心逻辑（日志之类的）放到代理类里。这样做的好处：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%8C%E6%98%AF%E5%AF%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3OOP%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%8C%E5%96%84%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9D%A5%E5%AE%9E%E7%8E%B0AOP%E3%80%82AOP%E7%9A%84%E6%80%9D%E6%83%B3%E5%B0%B1%E6%98%AF%E5%B0%86%E9%9D%9E%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E6%8F%90%E5%8F%96%E5%87%BA%E6%9D%A5%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BC%9A%E5%B0%86%E8%BF%99%E4%B8%AA%E5%88%87%E7%89%87%E6%8F%92%E5%85%A5%E5%88%B0%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E9%87%8C%EF%BC%8C%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9C%80%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AA%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.0.6.2.</span> <span class="nav-text">AOP是一种编程思想，是对面向对象编程思想OOP的一种完善，我们使用动态代理的技术来实现AOP。AOP的思想就是将非核心逻辑提取出来成为一个切面，使用动态代理的技术，当我们调用目标类的某一个方法的时候，会将这个切片插入到这个方法里，形成一个代理方法，最后执行的就是这个代理方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%9A%84%E6%9C%AF%E8%AF%AD%EF%BC%9A"><span class="nav-number">1.1.0.6.3.</span> <span class="nav-text">AOP编程思想的术语：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Aop%E7%BB%83%E4%B9%A0%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.1.0.6.4.</span> <span class="nav-text">Aop练习案例：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%9C%A8%E9%80%9A%E7%9F%A5%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.0.6.5.</span> <span class="nav-text">1、在通知中获取目标类的方法信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.1.0.6.6.</span> <span class="nav-text">2、方法返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E6%8D%95%E6%8D%89"><span class="nav-number">1.1.0.6.7.</span> <span class="nav-text">3、异常对象捕捉</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.1.0.6.8.</span> <span class="nav-text">AOP切点表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">1.1.0.6.9.</span> <span class="nav-text">切点表达式案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%8D%E7%94%A8"><span class="nav-number">1.1.0.6.10.</span> <span class="nav-text">切点表达式的复用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5"><span class="nav-number">1.1.0.6.11.</span> <span class="nav-text">环绕通知</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%87%E9%9D%A2%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.0.6.12.</span> <span class="nav-text">切面排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8XML%E6%9D%A5%E9%85%8D%E7%BD%AEAOP"><span class="nav-number">1.1.0.6.13.</span> <span class="nav-text">也可以使用XML来配置AOP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%88%91%E4%BB%AC%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%87%E7%89%87%E7%9A%84%E7%B1%BB%E6%9C%89%E6%97%A0%E6%8E%A5%E5%8F%A3%E6%9D%A5%E9%80%89%E6%8B%A9%E6%98%AF%E4%BD%BF%E7%94%A8jdk%E7%9A%84aop%E8%BF%98%E6%98%AF%E4%BD%BF%E7%94%A8cglib%E7%9A%84aop%E3%80%82%E5%A6%82%E6%9E%9C%E6%9C%89%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8jdk%E8%87%AA%E5%B8%A6%E7%9A%84%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%B0%B1%E7%94%A8cglib%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B8%A6%E7%9A%84jdkaop%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%A6%81%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9D%A5%E6%8E%A5%E6%94%B6%E6%B3%A8%E5%85%A5%E7%9A%84bean%E5%90%A6%E5%88%99%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%98%AF%E6%A0%B9%E6%8D%AE%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9B%B8%E5%BD%93%E4%BA%8E%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%9A%84%E5%85%84%E5%BC%9F%E7%B1%BB%E6%9D%A5%E4%BB%A3%E7%90%86%E7%9A%84%EF%BC%8C%E8%80%8Ccglib%E6%98%AF%E7%BB%A7%E6%89%BF%E7%9B%AE%E6%A0%87%E7%B1%BB%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%8E%A5%E6%94%B6bean"><span class="nav-number">1.1.0.6.14.</span> <span class="nav-text">注意事项：根据我们要使用切片的类有无接口来选择是使用jdk的aop还是使用cglib的aop。如果有接口使用jdk自带的，没有就用cglib，使用自带的jdkaop的时候，要使用接口来接收注入的bean否则会报错，因为底层的实现是根据这个接口实现一个类相当于目标类的兄弟类来代理的，而cglib是继承目标类的，可以使用目标类接收bean</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.1.0.7.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.1.0.7.1.</span> <span class="nav-text">编程式事务和声明式事务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.0.7.2.</span> <span class="nav-text">事务管理器和原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%9B%9E%E6%BB%9A%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%9B%9E%E6%BB%9A%E9%BB%98%E8%AE%A4%E5%9B%9E%E6%BB%9Aruntime%E5%BC%82%E5%B8%B8%EF%BC%8Cio%E5%BC%82%E5%B8%B8%E4%B8%8D%E4%BC%9A%E5%9B%9E%E6%BB%9A%EF%BC%8C%E6%89%80%E4%BB%A5%E5%8F%AF%E4%BB%A5%E9%85%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7rollbackfor%E4%B8%BAexception%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%A4%E7%A7%8D%E5%BC%82%E5%B8%B8%E9%83%BD%E6%8D%95%E6%8D%89%E5%9B%9E%E6%BB%9A%E4%BA%86"><span class="nav-number">1.1.0.7.3.</span> <span class="nav-text">异常回滚：异常回滚默认回滚runtime异常，io异常不会回滚，所以可以配置注解属性rollbackfor为exception，这样就可以将两种异常都捕捉回滚了</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SoulSend"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">SoulSend</p>
  <div class="site-description" itemprop="description">加油！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/29/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SoulSend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zard博客">
      <meta itemprop="description" content="加油！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="spring | Zard博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          spring
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-29T00:00:00+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-20 21:19:02" itemprop="dateModified" datetime="2024-11-20T21:19:02+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h1><p>尚硅谷的SSMu框架的课件：<a target="_blank" rel="noopener" href="https://www.wolai.com/v5Kuct5ZtPeVBk4NBUGBWF">快速掌握：全新SSM+Spring Boot+MyBatis-Plus实战精讲 (wolai.com)</a></p>
<p>源码的远程仓库：<a target="_blank" rel="noopener" href="https://github.com/SoulSend/Spring">SoulSend&#x2F;Spring: 学习SpringIoc容器和id的代码仓库 (github.com)</a></p>
<h2 id="Spring-framework"><a href="#Spring-framework" class="headerlink" title="Spring framework"></a>Spring framework</h2><h4 id="介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）"><a href="#介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）" class="headerlink" title="介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）"></a>介绍：这个框架是整个spring生态的基座，就干两件事：控制反转（IOC）和依赖注入（DI）</h4><p><strong>控制反转：</strong>就是将创建对象的权力交给容器，我们开发者就不用创建对象了，让容器给我们创建和管理对象。</p>
<p><strong>依赖注入：</strong>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p>
<p><strong>容器</strong>：有简单容器和复杂容器，简单容器就只有存储功能如：数组；复杂容器不仅有存储功能还有管理存储的内容的功能</p>
<p><strong>组件：</strong>组件就是一个可重复利用的对象，这个对象一般再容器里是单例的</p>
<p><strong>框架：</strong>框架和工具的区别：工具就是一个jar包，它是写死的，你只能这么用。而框架是：jar包加上配置文件，也就是说，框架可以根据配置文件来动态的改变功能，这就是他们俩的区别</p>
<h4 id="使用XML配置IOC容器的ioc-di"><a href="#使用XML配置IOC容器的ioc-di" class="headerlink" title="使用XML配置IOC容器的ioc&#x2F;di"></a>使用XML配置IOC容器的ioc&#x2F;di</h4><h5 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h5><ul>
<li><p>先编写你需要放入ioc容器的类</p>
</li>
<li><p>兴建一个xml文件，如果你已经导入spring框架，在idea中可以快捷建立一个XML配置文件，然后选中Spring配置文件就可以快速生成一个自带spring标签约束的xml文件</p>
</li>
<li><p>然后在xml文件中使用 <bean> 标签配置你要放入容器的类案例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 导入外部属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;atguigu.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;atguigu.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;atguigu.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;atguigu.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 JdbcTemplate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 装配数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.dao.impl.StudentDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbcTemplate&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.service.impl.StudentServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studentDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;studentDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.controller.StudentController&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;studentService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>id 属性是你放入的bean对象在ioc容器中唯一标识，在依赖注入时会用到</p>
</li>
<li><p>class 是目标类的全类名</p>
</li>
<li><p>当然，你可以指定一个bean对象的构造方法：构造器，工厂，这时的标签属性会有不同，可以看我远程仓库里的源码</p>
</li>
<li><p>打开bean标签里面，这个是di的配置，property是setter方法进行注入，name是setter方法去掉set，然后首字母小写的方法名字，value指定的是一个值，ref指定的是一个bean对象，这两个是setter方法的参数</p>
</li>
<li><p>然后就可以初始化一个ioc容器，获取bean对象了</p>
<p>更具体可以查看课件和源码。</p>
</li>
</ul>
<h4 id="使用注解配置ioc容器"><a href="#使用注解配置ioc容器" class="headerlink" title="使用注解配置ioc容器"></a>使用注解配置ioc容器</h4><h4 id="ioc配置使用步骤："><a href="#ioc配置使用步骤：" class="headerlink" title="ioc配置使用步骤："></a>ioc配置使用步骤：</h4><ul>
<li><p>准备你要放入容器的类</p>
</li>
<li><p>在不同的项目层面会有不同的注解，功能都是一模一样的，仅仅只是名字不一样，为了方便程序员标识不同的项目层次：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component：该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</span><br><span class="line"></span><br><span class="line">@Repository：该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</span><br><span class="line"></span><br><span class="line">@Service|该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</span><br><span class="line"></span><br><span class="line">@Controller：该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>将注解放到对应的项目层次</p>
</li>
<li><p>配置包扫描</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自动扫描的包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.包要精准,提高性能!</span></span><br><span class="line"><span class="comment">         2.会扫描指定的包和子包内容</span></span><br><span class="line"><span class="comment">         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.components&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 情况三：指定不扫描的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.components&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- context:exclude-filter标签：指定排除规则 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 情况四：仅扫描指定的组件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.ioc.components&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ioc容器内部的bean类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。</p>
</li>
</ul>
<h5 id="你可在注解后面指定value属性来设置bean的类名"><a href="#你可在注解后面指定value属性来设置bean的类名" class="headerlink" title="你可在注解后面指定value属性来设置bean的类名"></a>你可在注解后面指定value属性来设置bean的类名</h5><h5 id="引用DI配置步骤"><a href="#引用DI配置步骤" class="headerlink" title="引用DI配置步骤:"></a>引用DI配置步骤:</h5><ul>
<li>将你要注入的所有类装配进入ioc容器</li>
<li>在你要注入的属性上面添加@Autowired注解</li>
</ul>
<h5 id="注解流程："><a href="#注解流程：" class="headerlink" title="注解流程："></a>注解流程：</h5><ul>
<li>首先根据所需要的<strong>组件类型</strong>到 IOC 容器中查找</li>
<li>能够找到唯一的 bean：直接执行装配</li>
<li>如果完全找不到匹配这个类型的 bean：装配失败</li>
<li>和所需类型匹配的 bean 不止一个<ul>
<li>没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
<li>使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果注解下是一个接口，接口有多个实现类就会出现多个bean对象的异常抛出</p>
<h5 id="扩展JSR-250注解-Resource，这个注解就相当于：-Autowired-Qualifier"><a href="#扩展JSR-250注解-Resource，这个注解就相当于：-Autowired-Qualifier" class="headerlink" title="扩展JSR-250注解@Resource，这个注解就相当于：@Autowired + @Qualifier"></a>扩展JSR-250注解@Resource，这个注解就相当于：@Autowired + @Qualifier</h5><h5 id="基本类型DI配置："><a href="#基本类型DI配置：" class="headerlink" title="基本类型DI配置："></a>基本类型DI配置：</h5><ul>
<li><p>1、直接将值赋给基础类型</p>
</li>
<li><p>2、使用value可以获取外部配置文件里的值，但是需要在xml文件里读取外部配置文件，然后使用value注解获取配置文件里的值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--读取配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;value.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">@Value(&quot;$&#123;value.username&#125;&quot;)</span><br><span class="line">    private  String username;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="配置类（完全注解开发）"><a href="#配置类（完全注解开发）" class="headerlink" title="配置类（完全注解开发）"></a>配置类（完全注解开发）</h4><h5 id="使用配置类来代替XMl配置文件，用注解-Configuration来标注。在配置类里使用注解来配置ioc和di这样就脱离了xml配置文件，达成完全注解开发的目的"><a href="#使用配置类来代替XMl配置文件，用注解-Configuration来标注。在配置类里使用注解来配置ioc和di这样就脱离了xml配置文件，达成完全注解开发的目的" class="headerlink" title="使用配置类来代替XMl配置文件，用注解@Configuration来标注。在配置类里使用注解来配置ioc和di这样就脱离了xml配置文件，达成完全注解开发的目的"></a>使用配置类来代替XMl配置文件，用注解@Configuration来标注。在配置类里使用注解来配置ioc和di这样就脱离了xml配置文件，达成完全注解开发的目的</h5><p>使用步骤：</p>
<p>先使用@Configuration标注这是一个配置类然后使用两个注解</p>
<p>@Componentscan是包扫描注解</p>
<p>@PropertySource是引用外部的配置文件</p>
<p>在配置类的内部，使用@bean标签来标注一个组件，这个注解放在一个方法上，方法的返回值就是bean的类型，方法名就是bean的id。在这个方法里使用你的方法，不管是构造器还是工厂类来构建一个bean对象，同时使用setter方法来进行初始化。</p>
<p>读取配置类以后，要使用变量装配配置文件里的值，可以先使用Value注解将值赋给一个普通变量，然后通过set方法传参将这个变量注入到对应的bean对象里</p>
<h5 id="Import注解的使用"><a href="#Import注解的使用" class="headerlink" title="@Import注解的使用"></a>@Import注解的使用</h5><p>@Import 注释允许从另一个配置类加载 @Bean 定义，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> B <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，在实例化上下文时不需要同时指定 ConfigA.class 和 ConfigB.class ，只需显式提供 ConfigB ，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigB.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// now both beans A and B will be available...</span></span><br><span class="line">  <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> ctx.getBean(A.class);</span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的 @Configuration 类。</p>
<h4 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h4><p><strong>使用场景：</strong>当一个类的很多个方法都要添加一个相同的逻辑功能的时候，如果我们依次为每个方法添加，这样的效率非常低，且维护成本高，且代码耦合度也很高，这时我们你想了一个办法，将相同的逻辑提炼出来，当调用一个方法的时候，将这个提炼出来的逻辑动态的加入到这个方法中，这个就是AOP面向切面编程。</p>
<h5 id="代理模式：类似房客—–中介—–房东的关系，我们把一个方法的核心逻辑提取出来，非核心逻辑（日志之类的）放到代理类里。这样做的好处："><a href="#代理模式：类似房客—–中介—–房东的关系，我们把一个方法的核心逻辑提取出来，非核心逻辑（日志之类的）放到代理类里。这样做的好处：" class="headerlink" title="代理模式：类似房客—–中介—–房东的关系，我们把一个方法的核心逻辑提取出来，非核心逻辑（日志之类的）放到代理类里。这样做的好处："></a>代理模式：类似房客—–中介—–房东的关系，我们把一个方法的核心逻辑提取出来，非核心逻辑（日志之类的）放到代理类里。这样做的好处：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代理模式提供了一种结构化的方法来处理这些逻辑，使得代码更加模块化和易于管理。此外，代理模式允许在不修改目标对象的情况下，通过修改代理类来添加或更改非核心逻辑，这在某些情况下可以大大简化开发和维护工作。</span><br></pre></td></tr></table></figure>

<p><strong>静态代理：</strong>核心逻辑放到目标类的里面，然后代理类拥有一个目标类，我们直接调用代理类的对应的方法，在代理类里面，先有代理类执行非核心逻辑，再由代理类调用本身拥有的目标类的方法，执行核心逻辑。就是这么简单。具体实现查看代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补充说明：静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。</span><br><span class="line">提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</span><br></pre></td></tr></table></figure>

<p><strong>动态代理：</strong>动态代理是一种在运行时动态创建代理对象的代理模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动态代理技术分类</span><br><span class="line">- JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须**实现接口**！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子）</span><br><span class="line">- cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）</span><br></pre></td></tr></table></figure>



<h5 id="AOP是一种编程思想，是对面向对象编程思想OOP的一种完善，我们使用动态代理的技术来实现AOP。AOP的思想就是将非核心逻辑提取出来成为一个切面，使用动态代理的技术，当我们调用目标类的某一个方法的时候，会将这个切片插入到这个方法里，形成一个代理方法，最后执行的就是这个代理方法"><a href="#AOP是一种编程思想，是对面向对象编程思想OOP的一种完善，我们使用动态代理的技术来实现AOP。AOP的思想就是将非核心逻辑提取出来成为一个切面，使用动态代理的技术，当我们调用目标类的某一个方法的时候，会将这个切片插入到这个方法里，形成一个代理方法，最后执行的就是这个代理方法" class="headerlink" title="AOP是一种编程思想，是对面向对象编程思想OOP的一种完善，我们使用动态代理的技术来实现AOP。AOP的思想就是将非核心逻辑提取出来成为一个切面，使用动态代理的技术，当我们调用目标类的某一个方法的时候，会将这个切片插入到这个方法里，形成一个代理方法，最后执行的就是这个代理方法"></a>AOP是一种编程思想，是对面向对象编程思想OOP的一种完善，我们使用动态代理的技术来实现AOP。AOP的思想就是将非核心逻辑提取出来成为一个切面，使用动态代理的技术，当我们调用目标类的某一个方法的时候，会将这个切片插入到这个方法里，形成一个代理方法，最后执行的就是这个代理方法</h5><p><strong>总结一句话：</strong>AOP编程思想就是解决非核心业务代码冗余的问题的。大白话就是不重要的，但是所有方法都有的逻辑，将这个逻辑代码抽取成一个切片，然后动态分发给每一个方法。</p>
<h5 id="AOP编程思想的术语："><a href="#AOP编程思想的术语：" class="headerlink" title="AOP编程思想的术语："></a>AOP编程思想的术语：</h5><ul>
<li><strong>横切关注点</strong>：就是对非核心的哪些业务场景进行描述的一个术语，不然每次都说非核心业务很麻烦比如日志，事务哪些业务，与之相对的，核心代码业务就叫<strong>核心关注点</strong></li>
<li><strong>通知（增强）：</strong>就是前面说的切片，一个切片就是一个通知。也就是哪些提取出来的横切关注点的代码。每一个横切关注点上都要有一个方法来实现它，这个方法就是通知方法：<ul>
<li>前置通知：在被代理的目标类方法执行前的通知</li>
<li>返回通知：目标类的方法执行成功后执行的通知</li>
<li>异常通知：在目标类的方法执行出现异常的时候执行的通知</li>
<li>后置通知：目标类方法最终执行完毕后执行的通知</li>
<li>环绕通知：把目标方法包围的通知</li>
</ul>
</li>
<li><strong>连接点：</strong>目标类有很多方法，哪些方法要切入通知，哪些方法不需要切入通知，要切入通知的方法就是连接点，连接点就是用来标识我们通知的方法是哪个？是哪些方法需要切入通知。</li>
<li><strong>切入点：</strong>我们有多个连接点，被通知切入的连接点就是切入点</li>
<li><strong>切面：</strong>当我们的通知切入连接点以后就形成了一个切面</li>
<li><strong>目标：</strong>要被切入的对象或者说被代理的对象就是目标，前面的代理模式介绍过了</li>
<li><strong>代理：</strong>作为名词就是：目标类切入通知以后形成的代理类。作为动词就是：形成代理类的动作就叫代理</li>
<li><strong>织入：</strong>把通知应用到目标类上，生成代理类的过程就是织入，有静态织入和动态织入，其实就是静态代理和动态代理，spring用的是后者</li>
</ul>
<h5 id="Aop练习案例："><a href="#Aop练习案例：" class="headerlink" title="Aop练习案例："></a>Aop练习案例：</h5><ul>
<li><p>1、首先编写核心逻辑代码，将这些核心逻辑的类全部放入ioc容器</p>
</li>
<li><p>2、编写一个通知类，同时将这个类放入ioc容器，这个类里包含了你抽取出来的非核心逻辑，类上标注注解@Aspect，表明这是一个通知类</p>
</li>
<li><p>3、在通知类里编写具体的通知逻辑，根据通知的执行时间使用不同的注解</p>
</li>
<li><p>4、在注解内使用value属性，属性是一个字符串，字符串内写入execution(）这个方法，方法参数就是切入点表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Before(value = &quot;execution(* com.hrc.service.imp.CalculatorImp.add(int ,int))&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>5、开启spring的Aspect支持，在配置类上注解@EnableAspectJAutoProxy,或者xml配置文件编写&lt;aop:aspectj-autoproxy &#x2F;&gt;</p>
</li>
</ul>
<h5 id="1、在通知中获取目标类的方法信息"><a href="#1、在通知中获取目标类的方法信息" class="headerlink" title="1、在通知中获取目标类的方法信息"></a>1、在通知中获取目标类的方法信息</h5><p>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</p>
<ul>
<li>要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息）</li>
<li>要点2：通过目标方法签名对象获取方法名</li>
<li>要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组</li>
</ul>
<h5 id="2、方法返回值"><a href="#2、方法返回值" class="headerlink" title="2、方法返回值"></a>2、方法返回值</h5><p>在返回通知中，通过@AfterReturning注解的returning属性获取目标方法的返回值！</p>
<ul>
<li>在方法形参中声明你的返回值形参名字，在注解中给returning属性赋值你的形参名，这样就会将方法返回值封装给形参</li>
</ul>
<h5 id="3、异常对象捕捉"><a href="#3、异常对象捕捉" class="headerlink" title="3、异常对象捕捉"></a>3、异常对象捕捉</h5><p>在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象，使用方法同 2 一样</p>
<h5 id="AOP切点表达式"><a href="#AOP切点表达式" class="headerlink" title="AOP切点表达式"></a>AOP切点表达式</h5><p><strong>介绍：</strong>说白了就是一个通配字符串，用来匹配切点的</p>
<p><strong>语法</strong>:</p>
<ul>
<li>第一位：execution( ) 固定开头</li>
<li>第二位：方法访问修饰符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">private</span> 直接描述对应修饰符即可</span><br></pre></td></tr></table></figure>
<ul>
<li>第三位：方法返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> String <span class="keyword">void</span> 直接描述返回值类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>注意：

特殊情况 不考虑 访问修饰符和返回值

  execution(* * ) 这是错误语法

  execution(*) == 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了
</code></pre>
<ul>
<li>第四位：指定包的地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">固定的包: com.atguigu.api | service | dao</span><br><span class="line">单层的任意命名: com.atguigu.*  = com.atguigu.api  com.atguigu.dao  * = 任意一层的任意命名</span><br><span class="line">任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!</span><br><span class="line">注意: ..不能用作包开头   <span class="keyword">public</span> <span class="type">int</span> .. 错误语法  com..</span><br><span class="line">找到任何包下: *..</span><br></pre></td></tr></table></figure>
<ul>
<li>第五位：指定类名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">固定名称: UserService</span><br><span class="line">任意类名: *</span><br><span class="line">部分任意: com..service.impl.*Impl</span><br><span class="line">任意包任意类: *..*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>第六位：指定方法名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法和类名一致</span><br><span class="line">任意访问修饰符,任意类的任意方法: * *..*.*</span><br></pre></td></tr></table></figure>
<ul>
<li>第七位：方法参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第七位: 方法的参数描述</span><br><span class="line">       具体值: (String,<span class="type">int</span>) != (<span class="type">int</span>,String) 没有参数 ()</span><br><span class="line">       模糊值: 任意参数 有 或者 没有 (..)  ..任意参数的意识</span><br><span class="line">       部分具体和模糊:</span><br><span class="line">         第一个参数是字符串的方法 (String..)</span><br><span class="line">         最后一个参数是字符串 (..String)</span><br><span class="line">         字符串开头,<span class="type">int</span>结尾 (String..<span class="type">int</span>)</span><br><span class="line">         包含<span class="type">int</span>类型(..<span class="type">int</span>..)</span><br></pre></td></tr></table></figure>

<h5 id="切点表达式案例"><a href="#切点表达式案例" class="headerlink" title="切点表达式案例"></a>切点表达式案例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.查询某包某类下，访问修饰符是公有，返回值是int的全部方法</span><br><span class="line">2.查询某包下类中第一个参数是String的方法</span><br><span class="line">3.查询全部包下，无参数的方法！</span><br><span class="line">4.查询com包下，以int参数类型结尾的方法</span><br><span class="line">5.查询指定包下，Service开头类的私有返回值int的无参数方法</span><br></pre></td></tr></table></figure>

<h5 id="切点表达式的复用"><a href="#切点表达式的复用" class="headerlink" title="切点表达式的复用"></a>切点表达式的复用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、可以在定义一个方法，方法名返回值都随意，要无参。在方法上使用注解pointcut 属性calue值就是切点表达式，然后在其他通知方法的注解处将切点表达式修改为这个方法的调用就行</span><br><span class="line">2、创建一个存储切点的类，单独维护切点表达式，然后再通知类里调用这个切点表达式类的对应切点表达式方法</span><br></pre></td></tr></table></figure>

<h5 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h5><p>​	一个顶前面的所有通知，允许程序猿自己定义通知的位置，通过参数ProceedingJoinPoint 来获取目标方法，执行参数的proceed方法</p>
<h5 id="切面排序"><a href="#切面排序" class="headerlink" title="切面排序"></a>切面排序</h5><p>​	在切面类的上面添加注解@Order（数字），参数数字越小优先级越高，越高越先执行</p>
<h5 id="也可以使用XML来配置AOP"><a href="#也可以使用XML来配置AOP" class="headerlink" title="也可以使用XML来配置AOP"></a>也可以使用XML来配置AOP</h5><h5 id="注意事项：根据我们要使用切片的类有无接口来选择是使用jdk的aop还是使用cglib的aop。如果有接口使用jdk自带的，没有就用cglib，使用自带的jdkaop的时候，要使用接口来接收注入的bean否则会报错，因为底层的实现是根据这个接口实现一个类相当于目标类的兄弟类来代理的，而cglib是继承目标类的，可以使用目标类接收bean"><a href="#注意事项：根据我们要使用切片的类有无接口来选择是使用jdk的aop还是使用cglib的aop。如果有接口使用jdk自带的，没有就用cglib，使用自带的jdkaop的时候，要使用接口来接收注入的bean否则会报错，因为底层的实现是根据这个接口实现一个类相当于目标类的兄弟类来代理的，而cglib是继承目标类的，可以使用目标类接收bean" class="headerlink" title="注意事项：根据我们要使用切片的类有无接口来选择是使用jdk的aop还是使用cglib的aop。如果有接口使用jdk自带的，没有就用cglib，使用自带的jdkaop的时候，要使用接口来接收注入的bean否则会报错，因为底层的实现是根据这个接口实现一个类相当于目标类的兄弟类来代理的，而cglib是继承目标类的，可以使用目标类接收bean"></a>注意事项：根据我们要使用切片的类有无接口来选择是使用jdk的aop还是使用cglib的aop。如果有接口使用jdk自带的，没有就用cglib，使用自带的jdkaop的时候，要使用接口来接收注入的bean否则会报错，因为底层的实现是根据这个接口实现一个类相当于目标类的兄弟类来代理的，而cglib是继承目标类的，可以使用目标类接收bean</h5><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="编程式事务和声明式事务"><a href="#编程式事务和声明式事务" class="headerlink" title="编程式事务和声明式事务"></a>编程式事务和声明式事务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编程式事务要程序员自己编写事务代码，繁琐但自由</span><br><span class="line">声明式事务是框架提供给给程序员的，程序员只需要做好配置就可以直接使用</span><br></pre></td></tr></table></figure>

<h5 id="事务管理器和原理"><a href="#事务管理器和原理" class="headerlink" title="事务管理器和原理"></a>事务管理器和原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务也算是非核心代码，也就是横切关注点。我们可以使用AOP来实现事务的插入</span><br><span class="line">官方提供了一套事务管理器的接口，各个数据库的厂商自己实现自己的数据库的事务管理器，我们要是用哪个事务管理器，直接将对应的管理器放入ioc容器里面，然后在配置类里用@EnableTransactionManagement 打开spring1的事务支持就可以使用了事务了，怎么使用呢？在要添加事务的类或者方法上添加一个注解 @Transactional 它默认不采用只读，当我们要使用只读操作时可以设置onlyread为true。添加完注解时，spring为这个类创建一个aop创建一个代理，这个代理就有事务的代码和核心代码。</span><br><span class="line">事务管理器接口和事务管理器和关系就好像jdbc规范和数据库驱动一样</span><br><span class="line">原理我只是粗略的记录一番，如果忘记了还是要去课程的笔记看看</span><br></pre></td></tr></table></figure>

<h5 id="异常回滚：异常回滚默认回滚runtime异常，io异常不会回滚，所以可以配置注解属性rollbackfor为exception，这样就可以将两种异常都捕捉回滚了"><a href="#异常回滚：异常回滚默认回滚runtime异常，io异常不会回滚，所以可以配置注解属性rollbackfor为exception，这样就可以将两种异常都捕捉回滚了" class="headerlink" title="异常回滚：异常回滚默认回滚runtime异常，io异常不会回滚，所以可以配置注解属性rollbackfor为exception，这样就可以将两种异常都捕捉回滚了"></a>异常回滚：异常回滚默认回滚runtime异常，io异常不会回滚，所以可以配置注解属性rollbackfor为exception，这样就可以将两种异常都捕捉回滚了</h5><p><strong>事务隔离级别：</strong>避免事务并发导致数据不一致的问题使用isolation来设置隔离级<strong>别</strong></p>
<p><strong>事务传播行为：</strong>多个事务相互调用的时候，是加入还是不加入，在被调用的事务中声明</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaWeb/" rel="tag"># JavaWeb</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/05/29/vue-admin-template%E6%A8%A1%E6%9D%BF%E4%BD%BF%E7%94%A8/" rel="prev" title="前端后台页面模板使用">
                  <i class="fa fa-angle-left"></i> 前端后台页面模板使用
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/05/29/SSM%E6%A1%86%E6%9E%B6/" rel="next" title="SSM">
                  SSM <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SoulSend</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
